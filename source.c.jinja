
// Copyright 2015  Malcolm Inglis <http://minglis.id.au>
//
// This file is part of Libvec.
//
// Libvec is free software: you can redistribute it and/or modify it under
// the terms of the GNU Affero General Public License as published by the
// Free Software Foundation, either version 3 of the License, or (at your
// option) any later version.
//
// Libvec is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for
// more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with Libvec. If not, see <https://gnu.org/licenses/>.


// This file is the result of rendering:
//
//     {{template_path}}
//
// You should make changes to this file by tuning the build process, or (at a
// stretch) modifying the generation script or template file; not by editing
// this file as-is.


#include "vec_{{filename}}.h"

#include <errno.h>
#include <stdlib.h>

#include <libtypes/types.h>
#include <libmacro/assert.h>    // ASSERT
#include <libmacro/logic.h>     // IMPLIES
#include <libmacro/minmax.h>    // MIN, MAX
#include <libbase/size.h>       // size__*
#include <libarray/array_{{filename}}.h>

{% for path in sys_headers %}
#include <{{path}}>
{% endfor %}

{% for path in rel_headers %}
#include "{{path}}"
{% endfor %}


static size_t const init_capacity = 16;
static size_t const growth_mul = 2;


static
size_t
normalize_index( intmax_t const ix,
                 size_t const length )
{
    if ( ix >= 0 ) {
        return MIN( ( uintmax_t ) ix, SIZE_MAX );
    } else {
        if ( INTMAX_MAX < SIZE_MAX ) {
            size_t const pos_ix = -ix;
            if ( pos_ix > length ) {
                return 0;
            }
        } else {
            intmax_t const slength = length;
            if ( -slength > ix ) {
                return 0;
            }
        }
        return length + ix;
    }
}





bool
vec_{{funcname}}__is_valid(
        Vec_{{typename}} const xs )
{
    return IMPLIES( xs.e == NULL, xs.capacity == 0 )
        && xs.length <= xs.capacity;
}


Vec_{{typename}}
vec_{{funcname}}__new(
        {{type}} const * const elements,
        size_t const length,
        size_t const capacity )
{
    size_t const nlength = ( elements == NULL ) ? 0 : length;
    errno = 0;
    Vec_{{typename}} new = vec_{{funcname}}__new_alloc(
                               MAX( nlength, capacity ) );
    if ( errno ) { return ( Vec_{{typename}} ){ 0 }; }
    vec_{{funcname}}__memcpy_in( new, elements,
                                 size__mul( nlength, sizeof ( {{type}} ) ) );
    new.length = nlength;
    return new;
}


Vec_{{typename}}
vec_{{funcname}}__new_view(
        {{type}} * const elements,
        size_t const length,
        size_t const capacity )
{
    if ( elements == NULL ) {
        return ( Vec_{{typename}} ){ 0 };
    } else {
        return ( Vec_{{typename}} ){ .e        = elements,
                                     .length   = length,
                                     .capacity = MAX( length, capacity ) };
    }
}


Vec_{{typename}}
vec_{{funcname}}__new_alloc(
        size_t const capacity )
{
    Vec_{{typename}} new = { 0 };
    vec_{{funcname}}__realloc( &new, capacity );
    return new;
}


Vec_{{typename}}
vec_{{funcname}}__new_calloc(
        size_t const capacity )
{
    errno = 0;
    Vec_{{typename}} new = vec_{{funcname}}__new_alloc( capacity );
    if ( errno ) { return new; }
    vec_{{funcname}}__memzero( new );
    return new;
}


Vec_{{typename}}
vec_{{funcname}}__copy_vec(
        Vec_{{typename}} const vec )
{
    ASSERT( vec_{{funcname}}__is_valid( vec ) );

    return vec_{{funcname}}__new( vec.e, vec.length, vec.capacity );
}


Vec_{{typename}}
vec_{{funcname}}__copy_array(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__new( xs.e, xs.length, xs.length );
}


Vec_{{typename}}
vec_{{funcname}}__copyc_vec(
        Vec_{{typename}} const xs,
        size_t const capacity )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__new( xs.e, xs.length, capacity );
}


Vec_{{typename}}
vec_{{funcname}}__copyc_array(
        Array_{{typename}} const xs,
        size_t const capacity )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__new( xs.e, xs.length, capacity );
}


Vec_{{typename}}
vec_{{funcname}}__view_array(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return ( Vec_{{typename}} ){
        .e        = xs.e,
        .length   = xs.length,
        .capacity = xs.length
    };
}


void
vec_{{funcname}}__memcpy_in(
        Vec_{{typename}} const to,
        void const * const from,
        size_t const from_size )
{
    ASSERT( vec_{{funcname}}__is_valid( to ), from != NULL );

    array_{{funcname}}__memcpy_in(
        array_{{funcname}}__view_vec_whole( to ), from, from_size );
}


void
vec_{{funcname}}__memcpy_to(
        Vec_{{typename}} const from,
        void * const to,
        size_t const to_size )
{
    ASSERT( vec_{{funcname}}__is_valid( from ), to != NULL );

    array_{{funcname}}__memcpy_to(
        array_{{funcname}}__view_vec( from ), to, to_size );
}


void
vec_{{funcname}}__copy_into_vec(
        Vec_{{typename}} const from,
        Vec_{{typename}} const to )
{
    ASSERT( vec_{{funcname}}__is_valid( from ),
            vec_{{funcname}}__is_valid( to ) );

    vec_{{funcname}}__copy_into_vec_with( from, to, NULL );
}


void
vec_{{funcname}}__copy_into_vec_with(
        Vec_{{typename}} const from,
        Vec_{{typename}} const to,
        void ( * const copier )( {{type}} from, {{type}} * to ) )
{
    ASSERT( vec_{{funcname}}__is_valid( from ),
            vec_{{funcname}}__is_valid( to ) );

    vec_{{funcname}}__copy_into_array_with(
        from, array_{{funcname}}__view_vec( to ), copier );
}


void
vec_{{funcname}}__copy_into_array(
        Vec_{{typename}} const from,
        Array_{{typename}} const to )
{
    ASSERT( vec_{{funcname}}__is_valid( from ),
            array_{{funcname}}__is_valid( to ) );

    vec_{{funcname}}__copy_into_array_with( from, to, NULL );
}


void
vec_{{funcname}}__copy_into_array_with(
        Vec_{{typename}} const from,
        Array_{{typename}} const to,
        void ( * const copier )( {{type}} from, {{type}} * to ) )
{
    ASSERT( vec_{{funcname}}__is_valid( from ),
            array_{{funcname}}__is_valid( to ) );

    array_{{funcname}}__copy_into_array_with(
        array_{{funcname}}__view_vec( from ), to, copier );
}


void
vec_{{funcname}}__into_vec(
        Vec_{{typename}} const from,
        Vec_{{typename}} * const to )
{
    ASSERT( vec_{{funcname}}__is_valid( from ),
            to != NULL, vec_{{funcname}}__is_valid( *to ) );

    vec_{{funcname}}__into_vec_with( from, to, NULL, NULL );
}


void
vec_{{funcname}}__into_vec_with(
        Vec_{{typename}} const from,
        Vec_{{typename}} * const to,
        void ( * const copier )( {{type}} from, {{type}} * to ),
        void ( * const freer )( {{type}} * unused_to ) )
{
    ASSERT( vec_{{funcname}}__is_valid( from ),
            to != NULL, vec_{{funcname}}__is_valid( *to ) );

    errno = 0;
    vec_{{funcname}}__ensure_capacity( to, from.length );
    if ( errno ) { return; }
    to->length = from.length;
    Array_{{typename}} to_array = array_{{funcname}}__view_vec( *to );
    vec_{{funcname}}__into_array_with( from, &to_array, copier, freer );
    ASSERT( to->e == to_array.e,
            to->length == to_array.length );
}


void
vec_{{funcname}}__into_array(
        Vec_{{typename}} const from,
        Array_{{typename}} * const to )
{
    ASSERT( vec_{{funcname}}__is_valid( from ),
            to != NULL, array_{{funcname}}__is_valid( *to ) );

    vec_{{funcname}}__into_array_with( from, to, NULL, NULL );
}


void
vec_{{funcname}}__into_array_with(
        Vec_{{typename}} const from,
        Array_{{typename}} * const to,
        void ( * const copier )( {{type}} from, {{type}} * to ),
        void ( * const freer )( {{type}} * unused_to ) )
{
    ASSERT( vec_{{funcname}}__is_valid( from ),
            to != NULL, array_{{funcname}}__is_valid( *to ) );

    array_{{funcname}}__into_array_with(
            array_{{funcname}}__view_vec( from ), to, copier, freer );
}


void
vec_{{funcname}}__free(
        Vec_{{typename}} * const xs )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    vec_{{funcname}}__realloc( xs, 0 );
}


void
vec_{{funcname}}__realloc(
        Vec_{{typename}} * const xs,
        size_t const new_capacity )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    Array_{{typename}} array = array_{{funcname}}__view_vec_whole( *xs );
    array_{{funcname}}__realloc( &array, new_capacity );
    *xs = ( Vec_{{typename}} ){
              .e        = array.e,
              .length   = MIN( xs->length, new_capacity ),
              .capacity = new_capacity };
}


void
vec_{{funcname}}__grow_capacity(
        Vec_{{typename}} * const xs )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    if ( xs->capacity == 0 ) {
        vec_{{funcname}}__realloc( xs, init_capacity );
    } else if ( xs->capacity == size__max_bound() ) {
        errno = ENOMEM;
    } else {
        vec_{{funcname}}__realloc( xs,
            size__mul_b( xs->capacity, growth_mul ) );
    }
}


void
vec_{{funcname}}__grow_capacity_by(
        Vec_{{typename}} * const xs,
        size_t const to_grow )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    if ( to_grow == 0 ) {
        return;
    } else if ( !size__can_add( xs->capacity, to_grow ) ) {
        errno = ENOMEM;
    } else {
        vec_{{funcname}}__realloc( xs, xs->capacity + to_grow );
    }
}


void
vec_{{funcname}}__grow_capacity_for(
        Vec_{{typename}} * const xs,
        size_t const req_space )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    vec_{{funcname}}__grow_capacity_by(
            xs,
            size__sub_b( req_space,
                         vec_{{funcname}}__spare_capacity( *xs ) ) );
}


void
vec_{{funcname}}__ensure_capacity(
        Vec_{{typename}} * const xs,
        size_t const min_capacity )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    if ( xs->capacity < min_capacity ) {
        vec_{{funcname}}__realloc( xs, min_capacity );
    }
}


void
vec_{{funcname}}__shrink_capacity(
        Vec_{{typename}} * const xs )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    vec_{{funcname}}__realloc( xs, xs->capacity / 2 );
}


void
vec_{{funcname}}__shrink_capacity_to(
        Vec_{{typename}} * const xs,
        size_t const max_capacity )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    if ( xs->capacity > max_capacity ) {
        vec_{{funcname}}__realloc( xs, max_capacity );
    }
}


void
vec_{{funcname}}__shrink_capacity_by(
        Vec_{{typename}} * const xs,
        size_t const to_shrink )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    vec_{{funcname}}__realloc( xs,
            size__sub_b( xs->capacity, to_shrink ) );
}


void
vec_{{funcname}}__free_spare_capacity(
        Vec_{{typename}} * const xs )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    vec_{{funcname}}__shrink_capacity_by(
            xs, vec_{{funcname}}__spare_capacity( *xs ) );
}


{{type}} *
vec_{{funcname}}__elements(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return xs.e;
}


size_t
vec_{{funcname}}__length(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return xs.length;
}


size_t
vec_{{funcname}}__capacity(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return xs.capacity;
}


size_t
vec_{{funcname}}__spare_capacity(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return xs.capacity - xs.length;
}


size_t
vec_{{funcname}}__size(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return xs.capacity * sizeof ( {{type}} );
}


size_t
vec_{{funcname}}__size_length(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return xs.length * sizeof ( {{type}} );
}


bool
vec_{{funcname}}__is_empty(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return xs.length == 0;
}


bool
vec_{{funcname}}__isnt_empty(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return !vec_{{funcname}}__is_empty( xs );
}


bool
vec_{{funcname}}__is_full(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return xs.length == xs.capacity;
}


bool
vec_{{funcname}}__isnt_full(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return !vec_{{funcname}}__is_full( xs );
}


bool
vec_{{funcname}}__same(
        Vec_{{typename}} const xs,
        Vec_{{typename}} const ys )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            vec_{{funcname}}__is_valid( ys ) );

    return xs.e        == ys.e
        && xs.length   == ys.length
        && xs.capacity == ys.capacity;
}


{{type}}
vec_{{funcname}}__get(
        Vec_{{typename}} const xs,
        size_t const index )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), index < xs.length );

    return array_{{funcname}}__get(
               array_{{funcname}}__view_vec( xs ), index );
}


{{type}} *
vec_{{funcname}}__getp(
        Vec_{{typename}} const xs,
        size_t const index )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__getp(
               array_{{funcname}}__view_vec( xs ), index );
}


Maybe_{{typename}}
vec_{{funcname}}__getm(
        Vec_{{typename}} const xs,
        size_t const index )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__getm(
               array_{{funcname}}__view_vec( xs ), index );
}


{{type}}
vec_{{funcname}}__set(
        Vec_{{typename}} const xs,
        size_t const index,
        {{type}} const value )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), index < xs.length );

    return array_{{funcname}}__set(
               array_{{funcname}}__view_vec( xs ), index, value );
}


Maybe_{{typename}}
vec_{{funcname}}__setm(
        Vec_{{typename}} const xs,
        size_t const index,
        {{type}} const value )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), index < xs.length );

    return array_{{funcname}}__setm(
               array_{{funcname}}__view_vec( xs ), index, value );
}


void
vec_{{funcname}}__set_all(
        Vec_{{typename}} const xs,
        {{type}} const value )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    array_{{funcname}}__set_all(
        array_{{funcname}}__view_vec( xs ), value );
}


{{type}}
vec_{{funcname}}__set_first(
        Vec_{{typename}} const xs,
        {{type}} const value )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__set_first(
               array_{{funcname}}__view_vec( xs ), value );
}


{{type}}
vec_{{funcname}}__set_last(
        Vec_{{typename}} const xs,
        {{type}} const value )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__set_last(
               array_{{funcname}}__view_vec( xs ), value );
}


void
vec_{{funcname}}__memset(
        Vec_{{typename}} const xs,
        uchar const byte )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    array_{{funcname}}__memset(
        array_{{funcname}}__view_vec( xs ), byte );
}


void
vec_{{funcname}}__memzero(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    array_{{funcname}}__memzero(
        array_{{funcname}}__view_vec( xs ) );
}


void
vec_{{funcname}}__memset_whole(
        Vec_{{typename}} const xs,
        uchar const byte )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    array_{{funcname}}__memset(
        array_{{funcname}}__view_vec_whole( xs ), byte );
}


void
vec_{{funcname}}__memzero_whole(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    array_{{funcname}}__memzero(
        array_{{funcname}}__view_vec_whole( xs ) );
}


{{type}} *
vec_{{funcname}}__append(
        Vec_{{typename}} * const xs,
        {{type}} const x )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    if ( vec_{{funcname}}__is_full( *xs ) ) {
        errno = 0;
        vec_{{funcname}}__grow_capacity( xs );
        if ( errno ) { return NULL; }
    }
    {{type}} * const p = xs->e + xs->length;
    *p = x;
    xs->length++;
    return p;
}


{{type}}
vec_{{funcname}}__pop(
        Vec_{{typename}} * const xs )
{
    ASSERT( xs != NULL,
            vec_{{funcname}}__is_valid( *xs ),
            vec_{{funcname}}__isnt_empty( *xs ) );

    {{type}} const el = vec_{{funcname}}__last( *xs );
    xs->length--;
    return el;
}


void
vec_{{funcname}}__popn(
        Vec_{{typename}} * const xs,
        size_t const n )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    xs->length = size__sub_b( xs->length, n );
}


void
vec_{{funcname}}__empty(
        Vec_{{typename}} * const xs )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    xs->length = 0;
}


void
vec_{{funcname}}__empty_with(
        Vec_{{typename}} * const xs,
        void ( * const freer )( {{type}} * x ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ), freer != NULL );

    vec_{{funcname}}__eachp( *xs, .f = freer );
    vec_{{funcname}}__empty( xs );
}


void
vec_{{funcname}}__extend_array(
        Vec_{{typename}} * const xs,
        Array_{{typename}} const ext )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            array_{{funcname}}__is_valid( ext ) );

    errno = 0;
    vec_{{funcname}}__grow_capacity_for( xs, ext.length );
    if ( errno ) { return; }
    for ( size_t i = 0; i < ext.length; i++ ) {
        vec_{{funcname}}__append( xs, ext.e[ i ] );
        ASSERT( errno == 0 );
    }
}


void
vec_{{funcname}}__extend_vec(
        Vec_{{typename}} * const xs,
        Vec_{{typename}} const ext )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            vec_{{funcname}}__is_valid( ext ) );

    vec_{{funcname}}__extend_array( xs,
            array_{{funcname}}__view_vec( ext ) );
}


{{type}}
vec_{{funcname}}__first(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            vec_{{funcname}}__isnt_empty( xs ) );

    return array_{{funcname}}__first( array_{{funcname}}__view_vec( xs ) );
}


{{type}} *
vec_{{funcname}}__firstp(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__firstp( array_{{funcname}}__view_vec( xs ) );
}


Maybe_{{typename}}
vec_{{funcname}}__firstm(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__firstm( array_{{funcname}}__view_vec( xs ) );
}


{{type}}
vec_{{funcname}}__last(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            vec_{{funcname}}__isnt_empty( xs ) );

    return array_{{funcname}}__last( array_{{funcname}}__view_vec( xs ) );
}


{{type}} *
vec_{{funcname}}__lastp(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__lastp( array_{{funcname}}__view_vec( xs ) );
}


Maybe_{{typename}}
vec_{{funcname}}__lastm(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__lastm( array_{{funcname}}__view_vec( xs ) );
}


size_t
vec_{{funcname}}__count(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__count(
               array_{{funcname}}__view_vec( xs ), f );
}


size_t
vec_{{funcname}}__count_first(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__count_first(
               array_{{funcname}}__view_vec( xs ), f );
}


size_t
vec_{{funcname}}__count_last(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__count_last(
               array_{{funcname}}__view_vec( xs ), f );
}


Vec_{{typename}}
vec_{{funcname}}__take(
        Vec_{{typename}} const xs,
        size_t const n )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return xs;
    } else {
        return ( Vec_{{typename}} ){
                   .e        = xs.e,
                   .length   = n,
                   .capacity = xs.capacity };
    }
}


Vec_{{typename}}
vec_{{funcname}}__drop(
        Vec_{{typename}} const xs,
        size_t const n )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return ( Vec_{{typename}} ){ 0 };
    } else {
        return ( Vec_{{typename}} ){
                   .e        = xs.e + n,
                   .length   = xs.length - n,
                   .capacity = xs.capacity - n };
    }
}


Vec_{{typename}}
vec_{{funcname}}__take_end(
        Vec_{{typename}} const xs,
        size_t const n )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return xs;
    } else {
        return vec_{{funcname}}__drop( xs, xs.length - n );
    }
}


Vec_{{typename}}
vec_{{funcname}}__drop_end(
        Vec_{{typename}} const xs,
        size_t const n )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return ( Vec_{{typename}} ){ 0 };
    } else {
        return vec_{{funcname}}__take( xs, xs.length - n );
    }
}


Vec_{{typename}}
vec_{{funcname}}__take_while(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return vec_{{funcname}}__take(
               xs,
               vec_{{funcname}}__count_first( xs, f ) );
}


Vec_{{typename}}
vec_{{funcname}}__take_end_while(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return vec_{{funcname}}__take_end(
               xs,
               vec_{{funcname}}__count_last( xs, f ) );
}


Vec_{{typename}}
vec_{{funcname}}__drop_while(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return vec_{{funcname}}__drop(
               xs,
               vec_{{funcname}}__count_first( xs, f ) );
}


Vec_{{typename}}
vec_{{funcname}}__drop_end_while(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return vec_{{funcname}}__drop_end(
               xs,
               vec_{{funcname}}__count_last( xs, f ) );
}


Vec_{{typename}}
vec_{{funcname}}__slice(
        Vec_{{typename}} const xs,
        size_t const start,
        size_t const stop )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__drop(
               vec_{{funcname}}__take( xs, stop ),
               start );
}


Vec_{{typename}}
vec_{{funcname}}__slice_s(
        Vec_{{typename}} const xs,
        intmax_t const start,
        intmax_t const stop )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__slice(
               xs,
               normalize_index( start, xs.length ),
               normalize_index( stop, xs.length ) );
}


Vec_{{typename}}
vec_{{funcname}}__left_half(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__take( xs, xs.length / 2 );
}


Vec_{{typename}}
vec_{{funcname}}__right_half(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__drop( xs, xs.length / 2 );
}


Maybe_size
vec_{{funcname}}__find(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__find(
               array_{{funcname}}__view_vec( xs ), f );
}


Maybe_size
vec_{{funcname}}__find_not(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__find_not(
               array_{{funcname}}__view_vec( xs ), f );
}


Maybe_size
vec_{{funcname}}__find_last(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__find_last(
               array_{{funcname}}__view_vec( xs ), f );
}


Maybe_size
vec_{{funcname}}__find_last_not(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__find_last_not(
               array_{{funcname}}__view_vec( xs ), f );
}


{{type}} *
vec_{{funcname}}__findp(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__findp(
               array_{{funcname}}__view_vec( xs ), f );
}


{{type}} *
vec_{{funcname}}__findp_not(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__findp_not(
               array_{{funcname}}__view_vec( xs ), f );
}


{{type}} *
vec_{{funcname}}__findp_last(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__findp_last(
               array_{{funcname}}__view_vec( xs ), f );
}


{{type}} *
vec_{{funcname}}__findp_last_not(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__findp_last_not(
               array_{{funcname}}__view_vec( xs ), f );
}


Maybe_{{typename}}
vec_{{funcname}}__findm(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__findm(
               array_{{funcname}}__view_vec( xs ), f );
}


Maybe_{{typename}}
vec_{{funcname}}__findm_not(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__findm_not(
               array_{{funcname}}__view_vec( xs ), f );
}


Maybe_{{typename}}
vec_{{funcname}}__findm_last(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__findm_last(
               array_{{funcname}}__view_vec( xs ), f );
}


Maybe_{{typename}}
vec_{{funcname}}__findm_last_not(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__findm_last_not(
               array_{{funcname}}__view_vec( xs ), f );
}


bool
vec_{{funcname}}__any(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__any(
               array_{{funcname}}__view_vec( xs ), f );
}


bool
vec_{{funcname}}__all(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__all(
               array_{{funcname}}__view_vec( xs ), f );
}


bool
vec_{{funcname}}__only_one(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__only_one(
               array_{{funcname}}__view_vec( xs ), f );
}


bool
vec_{{funcname}}__all_but_one(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__all_but_one(
               array_{{funcname}}__view_vec( xs ), f );
}


{{type}}
vec_{{funcname}}__foldl(
        Vec_{{typename}} const xs,
        {{type}} const init,
        {{type}} ( * const f )( {{type}} acc, {{type}} x ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__foldl(
               array_{{funcname}}__view_vec( xs ), init, f );
}


{{type}}
vec_{{funcname}}__foldl1(
        Vec_{{typename}} xs,
        {{type}} ( * f )( {{type}} acc, {{type}} x ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), xs.length > 0, f != NULL );

    return array_{{funcname}}__foldl1(
               array_{{funcname}}__view_vec( xs ), f );
}


{{type}}
vec_{{funcname}}__foldr(
        Vec_{{typename}} xs,
        {{type}} init,
        {{type}} ( * f )( {{type}} x, {{type}} acc ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__foldr(
               array_{{funcname}}__view_vec( xs ), init, f );
}


{{type}}
vec_{{funcname}}__foldr1(
        Vec_{{typename}} xs,
        {{type}} ( * f )( {{type}} x, {{type}} acc ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), xs.length > 0, f != NULL );

    return array_{{funcname}}__foldr1(
               array_{{funcname}}__view_vec( xs ), f );
}


{{type}} *
vec_{{funcname}}__pick(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} * pick, {{type}} x ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__pick(
               array_{{funcname}}__view_vec( xs ), f );
}


bool
vec_{{funcname}}__equal_by(
        Vec_{{typename}} const xs,
        Vec_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            vec_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return vec_{{funcname}}__equal_array_by(
               xs, array_{{funcname}}__view_vec( ys ), eq );
}


bool
vec_{{funcname}}__equal_array_by(
        Vec_{{typename}} const xs,
        Array_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return array_{{funcname}}__equal_by(
               array_{{funcname}}__view_vec( xs ), ys, eq );
}


bool
vec_{{funcname}}__has_prefix_by(
        Vec_{{typename}} const xs,
        Vec_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            vec_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return array_{{funcname}}__has_prefix_by(
               array_{{funcname}}__view_vec( xs ),
               array_{{funcname}}__view_vec( ys ),
               eq );
}


bool
vec_{{funcname}}__has_suffix_by(
        Vec_{{typename}} const xs,
        Vec_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            vec_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return array_{{funcname}}__has_suffix_by(
               array_{{funcname}}__view_vec( xs ),
               array_{{funcname}}__view_vec( ys ),
               eq );
}


bool
vec_{{funcname}}__has_infix_by(
        Vec_{{typename}} const xs,
        Vec_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            vec_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return array_{{funcname}}__has_infix_by(
               array_{{funcname}}__view_vec( xs ),
               array_{{funcname}}__view_vec( ys ),
               eq );
}


Maybe_size
vec_{{funcname}}__infix_index_by(
        Vec_{{typename}} const xs,
        Vec_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            vec_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return array_{{funcname}}__infix_index_by(
               array_{{funcname}}__view_vec( xs ),
               array_{{funcname}}__view_vec( ys ),
               eq );
}


{{type}} *
vec_{{funcname}}__infix_ptr_by(
        Vec_{{typename}} const xs,
        Vec_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            vec_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return array_{{funcname}}__infix_ptr_by(
               array_{{funcname}}__view_vec( xs ),
               array_{{funcname}}__view_vec( ys ),
               eq );
}


size_t
vec_{{funcname}}__infix_count_by(
        Vec_{{typename}} const xs,
        Vec_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            vec_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return array_{{funcname}}__infix_count_by(
               array_{{funcname}}__view_vec( xs ),
               array_{{funcname}}__view_vec( ys ),
               eq );
}


bool
vec_{{funcname}}__elem_by(
        Vec_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), eq != NULL );

    return array_{{funcname}}__elem_by(
               array_{{funcname}}__view_vec( xs ), y, eq );
}


{{type}} *
vec_{{funcname}}__elem_ptr_by(
        Vec_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), eq != NULL );

    return array_{{funcname}}__elem_ptr_by(
               array_{{funcname}}__view_vec( xs ), y, eq );
}


Maybe_size
vec_{{funcname}}__elem_index_by(
        Vec_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), eq != NULL );

    return array_{{funcname}}__elem_index_by(
               array_{{funcname}}__view_vec( xs ), y, eq );
}


size_t
vec_{{funcname}}__elem_count_by(
        Vec_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), eq != NULL );

    return array_{{funcname}}__elem_count_by(
               array_{{funcname}}__view_vec( xs ), y, eq );
}


{{type}} *
vec_{{funcname}}__elem_or_append_by(
        Vec_{{typename}} * const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( *xs ), eq != NULL );

    {{type}} * const p = vec_{{funcname}}__elem_ptr_by( *xs, y, eq );
    if ( p == NULL ) {
        return vec_{{funcname}}__append( xs, y );
    } else {
        return p;
    }
}


void
vec_{{funcname}}__replacef(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} x ),
        {{type}} const repl )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    array_{{funcname}}__replacef(
        array_{{funcname}}__view_vec( xs ), f, repl );
}


Vec_{{typename}}
vec_{{funcname}}__replacedf(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} x ),
        {{type}} const repl )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    errno = 0;
    Vec_{{typename}} const new = vec_{{funcname}}__copy_vec( xs );
    if ( errno ) { return ( Vec_{{typename}} ){ 0 }; }
    vec_{{funcname}}__replacef( new, f, repl );
    return new;
}


void
vec_{{funcname}}__replace_by(
        Vec_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl,
        bool ( * const eq )( {{type}} x, {{type}} el ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), eq != NULL );

    array_{{funcname}}__replace_by(
        array_{{funcname}}__view_vec( xs ), el, repl, eq );
}


Vec_{{typename}}
vec_{{funcname}}__replaced_by(
        Vec_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl,
        bool ( * const eq )( {{type}} x, {{type}} el ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), eq != NULL );

    errno = 0;
    Vec_{{typename}} const new = vec_{{funcname}}__copy_vec( xs );
    if ( errno ) { return ( Vec_{{typename}} ){ 0 }; }
    vec_{{funcname}}__replace_by( new, el, repl, eq );
    return new;
}


static
void
filter( Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}} ),
        bool result )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ), f != NULL );

    size_t count = 0;
    for ( size_t i = 0; i < xs->length; i++ ) {
        {{type}} const el = xs->e[ i ];
        if ( f( el ) == result ) {
            xs->e[ count ] = el;
            count++;
        }
    }
    xs->length = count;
}


void
vec_{{funcname}}__filter(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ), f != NULL );

    filter( xs, f, true );
}


void
vec_{{funcname}}__filter_not(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ), f != NULL );

    filter( xs, f, false );
}


Vec_{{typename}}
vec_{{funcname}}__filtered(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    errno = 0;
    Vec_{{typename}} new = vec_{{funcname}}__copy_vec( xs );
    if ( errno ) { return ( Vec_{{typename}} ){ 0 }; }
    vec_{{funcname}}__filter( &new, f );
    return new;
}


Vec_{{typename}}
vec_{{funcname}}__filtered_not(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    errno = 0;
    Vec_{{typename}} new = vec_{{funcname}}__copy_vec( xs );
    if ( errno ) { return ( Vec_{{typename}} ){ 0 }; }
    vec_{{funcname}}__filter_not( &new, f );
    return new;
}


bool
vec_{{funcname}}__each_(
        Vec_{{typename}} const xs,
        struct vec_{{funcname}}__each__options const o )
{
    return array_{{funcname}}__each(
               array_{{funcname}}__view_vec( xs ),
               .f = o.f, .b = o.b, .fi = o.fi, .bi = o.bi,
               .fv = o.fv, .bv = o.bv, .fvi = o.fvi, .bvi = o.bvi,
               .where = o.where, .where_not = o.where_not,
               .v = o.v );
}


bool
vec_{{funcname}}__eachp_(
        Vec_{{typename}} const xs,
        struct vec_{{funcname}}__eachp__options const o )
{
    return array_{{funcname}}__eachp(
               array_{{funcname}}__view_vec( xs ),
               .f = o.f, .b = o.b, .fi = o.fi, .bi = o.bi,
               .fv = o.fv, .bv = o.bv, .fvi = o.fvi, .bvi = o.bvi,
               .where = o.where, .where_not = o.where_not,
               .v = o.v );
}


Array_{{typename}}
array_{{funcname}}__view_vec(
        Vec_{{typename}} const xs )
{
    return ( Array_{{typename}} ){ .e = xs.e, .length = xs.length };
}


Array_{{typename}}
array_{{funcname}}__copy_vec(
        Vec_{{typename}} const xs )
{
    return array_{{funcname}}__copy_array(
               array_{{funcname}}__view_vec( xs ) );
}


Array_{{typename}}
array_{{funcname}}__view_vec_whole(
        Vec_{{typename}} const xs )
{
    return ( Array_{{typename}} ){ .e = xs.e, .length = xs.capacity };
}


Array_{{typename}}
array_{{funcname}}__copy_vec_whole(
        Vec_{{typename}} const xs )
{
    return array_{{funcname}}__copy_array(
               array_{{funcname}}__view_vec_whole( xs ) );
}



{% macro typeclass_header(name) -%}
///////////////////////////////////
/// TYPECLASS: {{name}}
///////////////////////////////////
{%- endmacro %}

{% macro typeclass(name) -%}
{% if name in typeclasses %}
{{ typeclass_header(name) }}
{{ caller() }}
{% endif %}
{%- endmacro %}


{% call typeclass('EQ') %}


static
bool
equalf(
        {{type}} const x,
        {{type}} const y )
{
    // Might be a macro, so:
    return {{funcname}}__equal( x, y );
}


bool
vec_{{funcname}}__equal(
        Vec_{{typename}} const xs,
        Vec_{{typename}} const ys )
{
    return vec_{{funcname}}__equal_by( xs, ys, equalf );
}


bool
vec_{{funcname}}__not_equal(
        Vec_{{typename}} const xs,
        Vec_{{typename}} const ys )
{
    return !vec_{{funcname}}__equal( xs, ys );
}


bool
vec_{{funcname}}__equal_array(
        Vec_{{typename}} const xs,
        Array_{{typename}} const ys )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__is_valid( ys ) );

    return array_{{funcname}}__equal( array_{{funcname}}__view_vec( xs ), ys );
}


bool
vec_{{funcname}}__elem(
        Vec_{{typename}} const xs,
        {{type}} const y )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__elem_by( xs, y, equalf );
}


{{type}} *
vec_{{funcname}}__elem_ptr(
        Vec_{{typename}} const xs,
        {{type}} const y )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__elem_ptr_by( xs, y, equalf );
}


Maybe_size
vec_{{funcname}}__elem_index(
        Vec_{{typename}} const xs,
        {{type}} const y )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__elem_index_by( xs, y, equalf );
}


size_t
vec_{{funcname}}__elem_count(
        Vec_{{typename}} const xs,
        {{type}} const y )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__elem_count_by( xs, y, equalf );
}


{{type}} *
vec_{{funcname}}__elem_or_append(
        Vec_{{typename}} * const xs,
        {{type}} const y )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    return vec_{{funcname}}__elem_or_append_by( xs, y, equalf );
}


void
vec_{{funcname}}__replace(
        Vec_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    vec_{{funcname}}__replace_by( xs, el, repl, equalf );
}


Vec_{{typename}}
vec_{{funcname}}__replaced(
        Vec_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__replaced_by( xs, el, repl, equalf );
}

{% endcall %}


{% call typeclass('NUM') %}


static
size_t
strlen_null(
        {{type}} const * const xs )
{
    if ( xs == NULL ) { return 0; }
    size_t count = 0;
    while ( !{{funcname}}__equal( xs[ count ], {{funcname}}__zero() ) ) {
        count++;
    }
    return count;
}


Vec_{{typename}}
vec_{{funcname}}__view_strm(
        {{type}} * const xs )
{
    return vec_{{funcname}}__view_array(
               array_{{funcname}}__view_strm( xs ) );
}


Vec_{{typename}}
vec_{{funcname}}__copy_str(
        {{type}} const * const xs )
{
    return vec_{{funcname}}__view_array(
               array_{{funcname}}__copy_str( xs ) );
}


Vec_{{typename}}
vec_{{funcname}}__copyc_str(
        {{type}} const * const str,
        size_t const capacity )
{
    size_t const len = strlen_null( str );
    errno = 0;
    Vec_{{typename}} new = vec_{{funcname}}__new_alloc( MAX( len, capacity ) );
    if ( errno ) { return ( Vec_{{typename}} ){ 0 }; }
    vec_{{funcname}}__extend_str( &new, str );
    return new;
}


void
vec_{{funcname}}__extend_str(
        Vec_{{typename}} * const xs,
        {{type}} const * const ext )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    size_t const len = strlen_null( ext );
    errno = 0;
    vec_{{funcname}}__grow_capacity_for( xs, len );
    if ( errno ) { return; }
    for ( size_t i = 0; i < len; i++ ) {
        vec_{{funcname}}__append( xs, ext[ i ] );
        ASSERT( errno == 0 );
    }
}


bool
vec_{{funcname}}__last_is_zero(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    {{type}} * const lastp = vec_{{funcname}}__lastp( xs );
    return lastp != NULL && {{funcname}}__is_zero( *lastp );
}


{{type}} *
vec_{{funcname}}__append_zero(
        Vec_{{typename}} * const xs )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    return vec_{{funcname}}__append( xs, {{funcname}}__zero() );
}


{{type}} *
vec_{{funcname}}__term_zero(
        Vec_{{typename}} * const xs )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    if ( !vec_{{funcname}}__last_is_zero( *xs ) ) {
        vec_{{funcname}}__append_zero( xs );
    }
    return vec_{{funcname}}__lastp( *xs );
}


bool
vec_{{funcname}}__pop_zero(
        Vec_{{typename}} * const xs )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    if ( vec_{{funcname}}__last_is_zero( *xs ) ) {
        vec_{{funcname}}__pop( xs );
        return true;
    } else {
        return false;
    }
}


{% endcall %}


{% call typeclass('FROM_STR') %}


void
vec_{{funcname}}__arg_parse(
        char const * const name,
        char const * const value,
        void * const vec_ptr )
{
    ASSERT( value != NULL, vec_ptr != NULL );

    errno = 0;
    {{type}} const x = {{funcname}}__from_str( value );
    if ( errno ) { return; }
    Vec_{{typename}} * const v = vec_ptr;
    vec_{{funcname}}__append( v, x );
}


{% endcall %}

