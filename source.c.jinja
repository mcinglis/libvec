
// Copyright 2015  Malcolm Inglis <http://minglis.id.au>
//
// This file is part of Libvec.
//
// Libvec is free software: you can redistribute it and/or modify it under
// the terms of the GNU Affero General Public License as published by the
// Free Software Foundation, either version 3 of the License, or (at your
// option) any later version.
//
// Libvec is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for
// more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with Libvec. If not, see <https://gnu.org/licenses/>.


// This file is the result of rendering:
//
//     {{template_path}}
//
// You should make changes to this file by tuning the build process, or (at a
// stretch) modifying the generation script or template file; not by editing
// this file as-is.


{% if 'CHAR' in typeclasses %}
// For `vasprintf`:
#define _GNU_SOURCE
{% endif %}


#include "vec_{{filename}}.h"

#include <errno.h>
#include <stdlib.h>

#include <libtypes/types.h>
#include <libmacro/assert.h>    // ASSERT
#include <libmacro/logic.h>     // IMPLIES
#include <libmacro/minmax.h>    // MIN, MAX
#include <libbase/size.h>       // size__*
#include <libarray/array_{{filename}}.h>

{% for path in sys_headers %}
#include <{{path}}>
{% endfor %}

{% for path in rel_headers %}
#include "{{path}}"
{% endfor %}


static size_t const init_capacity = 16;
static size_t const growth_mul = 2;


static
size_t
normalize_index( intmax_t const ix,
                 size_t const length )
{
    if ( ix >= 0 ) {
        return MIN( ( uintmax_t ) ix, SIZE_MAX );
    } else {
        if ( INTMAX_MAX < SIZE_MAX ) {
            size_t const pos_ix = -ix;
            if ( pos_ix > length ) {
                return 0;
            }
        } else {
            intmax_t const slength = length;
            if ( -slength > ix ) {
                return 0;
            }
        }
        return length + ix;
    }
}





bool
vec_{{funcname}}__is_valid(
        Vec_{{typename}} const xs )
{
    return IMPLIES( xs.e == NULL, xs.capacity == 0 )
        && xs.length <= xs.capacity;
}


Vec_{{typename}}
vec_{{funcname}}__new(
        {{type}} const * const elements,
        size_t const length,
        size_t const capacity )
{
    size_t const nlength = ( elements == NULL ) ? 0 : length;
    errno = 0;
    size_t const sz = size__mul( nlength, sizeof ( {{type}} ) );
    if ( errno ) { return ( Vec_{{typename}} ){ 0 }; }
    Vec_{{typename}} new = vec_{{funcname}}__new_calloc(
                               MAX( nlength, capacity ) );
    if ( errno ) { return ( Vec_{{typename}} ){ 0 }; }
    vec_{{funcname}}__memcpy_from( new, elements, sz );
    new.length = nlength;
    return new;
}


Vec_{{typename}}
vec_{{funcname}}__new_view(
        {{type}} * const elements,
        size_t const length,
        size_t const capacity )
{
    if ( elements == NULL ) {
        return ( Vec_{{typename}} ){ 0 };
    } else {
        return ( Vec_{{typename}} ){ .e        = elements,
                                     .length   = length,
                                     .capacity = MAX( length, capacity ) };
    }
}


Vec_{{typename}}
vec_{{funcname}}__new_alloc(
        size_t const capacity )
{
    Vec_{{typename}} new = { 0 };
    vec_{{funcname}}__realloc( &new, capacity );
    return new;
}


Vec_{{typename}}
vec_{{funcname}}__new_calloc(
        size_t const capacity )
{
    errno = 0;
    Vec_{{typename}} new = vec_{{funcname}}__new_alloc( capacity );
    if ( errno ) { return new; }
    vec_{{funcname}}__memzero( new );
    return new;
}


Vec_{{typename}}
vec_{{funcname}}__new_empty(
        void )
{
    return ( Vec_{{typename}} ){ .e = NULL, .length = 0, .capacity = 0 };
}


void
vec_{{funcname}}__free(
        Vec_{{typename}} * const xs )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    vec_{{funcname}}__realloc( xs, 0 );
}


void
vec_{{funcname}}__realloc(
        Vec_{{typename}} * const xs,
        size_t const new_capacity )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    vec_{{funcname}}__realloc_with( xs, new_capacity, NULL );
}


void
vec_{{funcname}}__realloc_with(
        Vec_{{typename}} * const xs,
        size_t const new_capacity,
        void ( * const freer )( {{type}} * lost_el ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    ArrayM_{{typename}} array = arraym_{{funcname}}__view_vec_whole( *xs );
    arraym_{{funcname}}__realloc_with( &array, new_capacity, freer );
    if ( errno ) { return; }
    *xs = ( Vec_{{typename}} ){
              .e        = array.e,
              .length   = MIN( xs->length, new_capacity ),
              .capacity = new_capacity };
}


Vec_{{typename}}
vec_{{funcname}}__view_arraym(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return ( Vec_{{typename}} ){
               .e        = xs.e,
               .length   = xs.length,
               .capacity = xs.length };
}


void
vec_{{funcname}}__memcpy_from(
        Vec_{{typename}} const to,
        void const * const from,
        size_t const from_size )
{
    ASSERT( vec_{{funcname}}__is_valid( to ) );

    arraym_{{funcname}}__memcpy_from(
        arraym_{{funcname}}__view_vec_whole( to ), from, from_size );
}


void
vec_{{funcname}}__memcpy_to(
        Vec_{{typename}} const from,
        void * const to,
        size_t const to_size )
{
    ASSERT( vec_{{funcname}}__is_valid( from ) );

    arraym_{{funcname}}__memcpy_to(
        arraym_{{funcname}}__view_vec( from ), to, to_size );
}


Vec_{{typename}}
vec_{{funcname}}__copy_vec(
        Vec_{{typename}} const from )
{
    ASSERT( vec_{{funcname}}__is_valid( from ) );

    return vec_{{funcname}}__copy_vec_with( from, NULL );
}


Vec_{{typename}}
vec_{{funcname}}__copy_vec_with(
        Vec_{{typename}} const from,
        void ( * const copier )( {{type}} * new_el, {{type}} from_el ) )
{
    ASSERT( vec_{{funcname}}__is_valid( from ) );

    Vec_{{typename}} new = vec_{{funcname}}__new_empty();
    vec_{{funcname}}__copy_vec_into_with( &new, from, copier );
    return new;
}


Vec_{{typename}}
vec_{{funcname}}__copy_arrayc(
        ArrayC_{{typename}} const from )
{
    ASSERT( arrayc_{{funcname}}__is_valid( from ) );

    return vec_{{funcname}}__copy_arrayc_with( from, NULL );
}


Vec_{{typename}}
vec_{{funcname}}__copy_arrayc_with(
        ArrayC_{{typename}} const from,
        void ( * const copier )( {{type}} * new_el, {{type}} from_el ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( from ) );

    Vec_{{typename}} new = vec_{{funcname}}__new_empty();
    vec_{{funcname}}__copy_arrayc_into_with( &new, from, copier );
    return new;
}


Vec_{{typename}}
vec_{{funcname}}__copy_arraym(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__copy_arrayc(
               arrayc_{{funcname}}__view_arraym( xs ) );
}


Vec_{{typename}}
vec_{{funcname}}__copy_arraym_with(
        ArrayM_{{typename}} const from,
        void ( * const copier )( {{type}} * new_el, {{type}} from_el ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( from ) );

    return vec_{{funcname}}__copy_arrayc_with(
               arrayc_{{funcname}}__view_arraym( from ), copier );
}


Vec_{{typename}}
vec_{{funcname}}__copyc_vec(
        Vec_{{typename}} const xs,
        size_t const capacity )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__new( xs.e, xs.length, capacity );
}


Vec_{{typename}}
vec_{{funcname}}__copyc_arrayc(
        ArrayC_{{typename}} const xs,
        size_t const capacity )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__new( xs.e, xs.length, capacity );
}


Vec_{{typename}}
vec_{{funcname}}__copyc_arraym(
        ArrayM_{{typename}} const xs,
        size_t const capacity )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__new( xs.e, xs.length, capacity );
}


void
vec_{{funcname}}__copy_vec_into(
        Vec_{{typename}} * const to,
        Vec_{{typename}} const from )
{
    ASSERT( to != NULL, vec_{{funcname}}__is_valid( *to ),
            vec_{{funcname}}__is_valid( from ) );

    vec_{{funcname}}__copy_vec_into_with( to, from, NULL );
}


void
vec_{{funcname}}__copy_vec_into_with(
        Vec_{{typename}} * const to,
        Vec_{{typename}} const from,
        void ( * const copier )( {{type}} * to_el, {{type}} from_el ) )
{
    ASSERT( to != NULL, vec_{{funcname}}__is_valid( *to ),
            vec_{{funcname}}__is_valid( from ) );

    vec_{{funcname}}__copy_arrayc_into_with(
        to, arrayc_{{funcname}}__view_vec( from ), copier );
}


void
vec_{{funcname}}__copy_arrayc_into(
        Vec_{{typename}} * const to,
        ArrayC_{{typename}} const from )
{
    ASSERT( to != NULL, vec_{{funcname}}__is_valid( *to ),
            arrayc_{{funcname}}__is_valid( from ) );

    vec_{{funcname}}__copy_arrayc_into_with( to, from, NULL );
}


void
vec_{{funcname}}__copy_arrayc_into_with(
        Vec_{{typename}} * const to,
        ArrayC_{{typename}} const from,
        void ( * const copier )( {{type}} * to_el, {{type}} from_el ) )
{
    ASSERT( to != NULL, vec_{{funcname}}__is_valid( *to ),
            arrayc_{{funcname}}__is_valid( from ) );

    vec_{{funcname}}__ensure_capacity( to, from.length );
    if ( errno ) { return; }
    to->length = from.length;
    ASSERT( to->length <= to->capacity );
    arrayc_{{funcname}}__copy_into_arraym_with(
        from, arraym_{{funcname}}__view_vec( *to ), copier );
}


void
vec_{{funcname}}__copy_arraym_into(
        Vec_{{typename}} * const to,
        ArrayM_{{typename}} const from )
{
    ASSERT( to != NULL, vec_{{funcname}}__is_valid( *to ),
            arraym_{{funcname}}__is_valid( from ) );

    vec_{{funcname}}__copy_arraym_into_with( to, from, NULL );
}


void
vec_{{funcname}}__copy_arraym_into_with(
        Vec_{{typename}} * const to,
        ArrayM_{{typename}} const from,
        void ( * const copier )( {{type}} * to_el, {{type}} from_el ) )
{
    ASSERT( to != NULL, vec_{{funcname}}__is_valid( *to ),
            arraym_{{funcname}}__is_valid( from ) );

    vec_{{funcname}}__copy_arrayc_into_with(
        to, arrayc_{{funcname}}__view_arraym( from ), copier );
}


void
vec_{{funcname}}__grow_capacity(
        Vec_{{typename}} * const xs )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    errno = 0;
    if ( xs->capacity == 0 ) {
        vec_{{funcname}}__realloc( xs, init_capacity );
    } else if ( xs->capacity == size__max_bound() ) {
        errno = ENOMEM;
    } else {
        vec_{{funcname}}__realloc( xs,
            size__mul_b( xs->capacity, growth_mul ) );
    }
}


void
vec_{{funcname}}__grow_capacity_by(
        Vec_{{typename}} * const xs,
        size_t const to_grow )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    errno = 0;
    if ( to_grow == 0 ) {
        return;
    } else if ( !size__can_add( xs->capacity, to_grow ) ) {
        errno = ENOMEM;
    } else {
        vec_{{funcname}}__realloc( xs, xs->capacity + to_grow );
    }
}


void
vec_{{funcname}}__grow_capacity_for(
        Vec_{{typename}} * const xs,
        size_t const req_space )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    errno = 0;
    size_t new_capacity = xs->capacity;
    while ( ( new_capacity - xs->length ) < req_space ) {
        if ( new_capacity == size__max_bound() ) {
            errno = ENOMEM;
            return;
        }
        new_capacity = new_capacity == 0
                       ? init_capacity
                       : size__mul_b( new_capacity, growth_mul );
    }
    vec_{{funcname}}__realloc( xs, new_capacity );
}


void
vec_{{funcname}}__ensure_capacity(
        Vec_{{typename}} * const xs,
        size_t const min_capacity )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    errno = 0;
    if ( xs->capacity < min_capacity ) {
        vec_{{funcname}}__realloc( xs, min_capacity );
    }
}


void
vec_{{funcname}}__shrink_capacity(
        Vec_{{typename}} * const xs )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    vec_{{funcname}}__realloc( xs, xs->capacity / 2 );
}


void
vec_{{funcname}}__shrink_capacity_to(
        Vec_{{typename}} * const xs,
        size_t const max_capacity )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    errno = 0;
    if ( xs->capacity > max_capacity ) {
        vec_{{funcname}}__realloc( xs, max_capacity );
    }
}


void
vec_{{funcname}}__shrink_capacity_by(
        Vec_{{typename}} * const xs,
        size_t const to_shrink )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    vec_{{funcname}}__realloc( xs,
            size__sub_b( xs->capacity, to_shrink ) );
}


void
vec_{{funcname}}__free_spare_capacity(
        Vec_{{typename}} * const xs )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    vec_{{funcname}}__shrink_capacity_by(
            xs, vec_{{funcname}}__spare_capacity( *xs ) );
}


{{type}} *
vec_{{funcname}}__elements(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return xs.e;
}


size_t
vec_{{funcname}}__length(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return xs.length;
}


size_t
vec_{{funcname}}__capacity(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return xs.capacity;
}


size_t
vec_{{funcname}}__spare_capacity(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return xs.capacity - xs.length;
}


size_t
vec_{{funcname}}__size(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return xs.capacity * sizeof ( {{type}} );
}


size_t
vec_{{funcname}}__size_length(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return xs.length * sizeof ( {{type}} );
}


bool
vec_{{funcname}}__is_empty(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return xs.length == 0;
}


bool
vec_{{funcname}}__isnt_empty(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return !vec_{{funcname}}__is_empty( xs );
}


bool
vec_{{funcname}}__is_full(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return xs.length == xs.capacity;
}


bool
vec_{{funcname}}__isnt_full(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return !vec_{{funcname}}__is_full( xs );
}


bool
vec_{{funcname}}__same(
        Vec_{{typename}} const xs,
        Vec_{{typename}} const ys )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            vec_{{funcname}}__is_valid( ys ) );

    return xs.e        == ys.e
        && xs.length   == ys.length
        && xs.capacity == ys.capacity;
}


{{type}}
vec_{{funcname}}__get(
        Vec_{{typename}} const xs,
        size_t const index )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), index < xs.length );

    return arraym_{{funcname}}__get(
               arraym_{{funcname}}__view_vec( xs ), index );
}


{{type}} *
vec_{{funcname}}__getp(
        Vec_{{typename}} const xs,
        size_t const index )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__getp(
               arraym_{{funcname}}__view_vec_whole( xs ), index );
}


Maybe_{{typename}}
vec_{{funcname}}__getm(
        Vec_{{typename}} const xs,
        size_t const index )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__getm(
               arraym_{{funcname}}__view_vec( xs ), index );
}


{{type}}
vec_{{funcname}}__set(
        Vec_{{typename}} const xs,
        size_t const index,
        {{type}} const value )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), index < xs.length );

    return arraym_{{funcname}}__set(
               arraym_{{funcname}}__view_vec( xs ), index, value );
}


Maybe_{{typename}}
vec_{{funcname}}__setm(
        Vec_{{typename}} const xs,
        size_t const index,
        {{type}} const value )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), index < xs.length );

    return arraym_{{funcname}}__setm(
               arraym_{{funcname}}__view_vec( xs ), index, value );
}


void
vec_{{funcname}}__set_all(
        Vec_{{typename}} const xs,
        {{type}} const value )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    arraym_{{funcname}}__set_all(
        arraym_{{funcname}}__view_vec( xs ), value );
}


{{type}}
vec_{{funcname}}__set_first(
        Vec_{{typename}} const xs,
        {{type}} const value )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__set_first(
               arraym_{{funcname}}__view_vec( xs ), value );
}


{{type}}
vec_{{funcname}}__set_last(
        Vec_{{typename}} const xs,
        {{type}} const value )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__set_last(
               arraym_{{funcname}}__view_vec( xs ), value );
}


void
vec_{{funcname}}__memset(
        Vec_{{typename}} const xs,
        uchar const byte )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    arraym_{{funcname}}__memset(
        arraym_{{funcname}}__view_vec( xs ), byte );
}


void
vec_{{funcname}}__memzero(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    arraym_{{funcname}}__memzero(
        arraym_{{funcname}}__view_vec( xs ) );
}


void
vec_{{funcname}}__memset_whole(
        Vec_{{typename}} const xs,
        uchar const byte )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    arraym_{{funcname}}__memset(
        arraym_{{funcname}}__view_vec_whole( xs ), byte );
}


void
vec_{{funcname}}__memzero_whole(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    arraym_{{funcname}}__memzero(
        arraym_{{funcname}}__view_vec_whole( xs ) );
}


void
vec_{{funcname}}__memzero_spare(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    arraym_{{funcname}}__memzero(
        arraym_{{funcname}}__view_vec_spare( xs ) );
}


void
vec_{{funcname}}__empty(
        Vec_{{typename}} * const xs )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    xs->length = 0;
}


void
vec_{{funcname}}__empty_with(
        Vec_{{typename}} * const xs,
        void ( * const freer )( {{type}} * x ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ), freer != NULL );

    vec_{{funcname}}__eachp( *xs, .f = freer );
    vec_{{funcname}}__empty( xs );
}


void
vec_{{funcname}}__swap(
        Vec_{{typename}} const xs,
        size_t const i,
        size_t const j )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), i < xs.length, j < xs.length );

    {{type}} * const i_el = vec_{{funcname}}__getp( xs, i );
    {{type}} * const j_el = vec_{{funcname}}__getp( xs, j );
    ASSERT( i_el != NULL, j_el != NULL );
    {{type}} const tmp = *i_el;
    *i_el = *j_el;
    *j_el = tmp;
}


{{type}} *
vec_{{funcname}}__insert(
        Vec_{{typename}} * const xs,
        size_t const at,
        {{type}} const x )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            at <= xs->length );

    return vec_{{funcname}}__insert_with( xs, at, x, NULL );
}


{{type}} *
vec_{{funcname}}__insert_with(
        Vec_{{typename}} * const xs,
        size_t const at,
        {{type}} const x,
        void ( * const copier )( {{type}} * to, {{type}} from ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            at <= xs->length );

    return vec_{{funcname}}__insert_arrayc_with(
               xs, at, ARRAYC_{{macroname}}( x ), copier );
}


{{type}} *
vec_{{funcname}}__insert_arrayc(
        Vec_{{typename}} * const xs,
        size_t const at,
        ArrayC_{{typename}} const ys )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            at <= xs->length,
            arrayc_{{funcname}}__is_valid( ys ) );

    return vec_{{funcname}}__insert_arrayc_with( xs, at, ys, NULL );
}


{{type}} *
vec_{{funcname}}__insert_arrayc_with(
        Vec_{{typename}} * const xs,
        size_t const at,
        ArrayC_{{typename}} const ys,
        void ( * const copier )( {{type}} * to, {{type}} from ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            at <= xs->length,
            arrayc_{{funcname}}__is_valid( ys ) );

    vec_{{funcname}}__grow_capacity_for( xs, ys.length );
    if ( errno ) { return NULL; }
    // Growth of `xs` didn't fail, so:
    ASSERT( size__can_add( xs->length, ys.length ) );
    // Move along the elements of `xs` per the length of `ys`:
    for ( size_t i = xs->length; i > at; i-- ) {
        xs->e[ ( i - 1 ) + ys.length ] = xs->e[ i - 1 ];
    }
    xs->length += ys.length;
    // Insert the elements of `ys` at `at` (now that they've been moved):
    for ( size_t i = 0; i < ys.length; i++ ) {
        {{type}} * const xs_e = vec_{{funcname}}__getp( *xs, at + i );
        {{type}} const ys_e = arrayc_{{funcname}}__get( ys, i );
        if ( copier == NULL ) {
            *xs_e = ys_e;
        } else {
            errno = 0;
            copier( xs_e, ys_e );
            if ( errno ) { return NULL; }
        }
    }
    return vec_{{funcname}}__getp( *xs, at );
}


{{type}} *
vec_{{funcname}}__insert_arraym(
        Vec_{{typename}} * const xs,
        size_t const at,
        ArrayM_{{typename}} const ys )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            at <= xs->length,
            arraym_{{funcname}}__is_valid( ys ) );

    return vec_{{funcname}}__insert_arraym_with( xs, at, ys, NULL );
}


{{type}} *
vec_{{funcname}}__insert_arraym_with(
        Vec_{{typename}} * const xs,
        size_t const at,
        ArrayM_{{typename}} const ys,
        void ( * const copier )( {{type}} * to, {{type}} from ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            at <= xs->length,
            arraym_{{funcname}}__is_valid( ys ) );

    return vec_{{funcname}}__insert_arrayc_with(
               xs, at, arrayc_{{funcname}}__view_arraym( ys ), copier );
}


{{type}} *
vec_{{funcname}}__insert_vec(
        Vec_{{typename}} * const xs,
        size_t const at,
        Vec_{{typename}} const ys )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            at <= xs->length,
            vec_{{funcname}}__is_valid( ys ) );

    return vec_{{funcname}}__insert_vec_with( xs, at, ys, NULL );
}


{{type}} *
vec_{{funcname}}__insert_vec_with(
        Vec_{{typename}} * const xs,
        size_t const at,
        Vec_{{typename}} const ys,
        void ( * const copier )( {{type}} * to, {{type}} from ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            at <= xs->length,
            vec_{{funcname}}__is_valid( ys ) );

    return vec_{{funcname}}__insert_arrayc_with(
               xs, at, arrayc_{{funcname}}__view_vec( ys ), copier );
}


{{type}} *
vec_{{funcname}}__append(
        Vec_{{typename}} * const xs,
        {{type}} const x )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    return vec_{{funcname}}__append_with( xs, x, NULL );
}


{{type}} *
vec_{{funcname}}__append_with(
        Vec_{{typename}} * const xs,
        {{type}} const x,
        void ( * const copier )( {{type}} * to, {{type}} from ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    return vec_{{funcname}}__append_arrayc_with(
               xs, ARRAYC_{{macroname}}( x ), copier );
}


{{type}} *
vec_{{funcname}}__append_arrayc(
        Vec_{{typename}} * const xs,
        ArrayC_{{typename}} const ext )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            arrayc_{{funcname}}__is_valid( ext ) );

    return vec_{{funcname}}__append_arrayc_with( xs, ext, NULL );
}


{{type}} *
vec_{{funcname}}__append_arrayc_with(
        Vec_{{typename}} * const xs,
        ArrayC_{{typename}} const ext,
        void ( * const copier )( {{type}} * to, {{type}} from ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            arrayc_{{funcname}}__is_valid( ext ) );

    return vec_{{funcname}}__insert_arrayc_with(
               xs, xs->length, ext, copier );
}


{{type}} *
vec_{{funcname}}__append_arraym(
        Vec_{{typename}} * const xs,
        ArrayM_{{typename}} const ext )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            arraym_{{funcname}}__is_valid( ext ) );

    return vec_{{funcname}}__append_arraym_with( xs, ext, NULL );
}


{{type}} *
vec_{{funcname}}__append_arraym_with(
        Vec_{{typename}} * const xs,
        ArrayM_{{typename}} const ext,
        void ( * const copier )( {{type}} * to, {{type}} from ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            arraym_{{funcname}}__is_valid( ext ) );

    return vec_{{funcname}}__append_arrayc_with(
               xs, arrayc_{{funcname}}__view_arraym( ext ), copier );
}


{{type}} *
vec_{{funcname}}__append_vec(
        Vec_{{typename}} * const xs,
        Vec_{{typename}} const ext )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            vec_{{funcname}}__is_valid( ext ) );

    return vec_{{funcname}}__append_vec_with( xs, ext, NULL );
}


{{type}} *
vec_{{funcname}}__append_vec_with(
        Vec_{{typename}} * const xs,
        Vec_{{typename}} const ext,
        void ( * const copier )( {{type}} * to, {{type}} from ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            vec_{{funcname}}__is_valid( ext ) );

    return vec_{{funcname}}__append_arrayc_with(
               xs, arrayc_{{funcname}}__view_vec( ext ), copier );
}


{{type}} *
vec_{{funcname}}__prepend(
        Vec_{{typename}} * const xs,
        {{type}} const x )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    return vec_{{funcname}}__prepend_with( xs, x, NULL );
}


{{type}} *
vec_{{funcname}}__prepend_with(
        Vec_{{typename}} * const xs,
        {{type}} const x,
        void ( * const copier )( {{type}} * to, {{type}} from ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    return vec_{{funcname}}__prepend_arrayc_with(
               xs, ARRAYC_{{macroname}}( x ), copier );
}


{{type}} *
vec_{{funcname}}__prepend_arrayc(
        Vec_{{typename}} * const xs,
        ArrayC_{{typename}} const ext )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            arrayc_{{funcname}}__is_valid( ext ) );

    return vec_{{funcname}}__prepend_arrayc_with( xs, ext, NULL );
}


{{type}} *
vec_{{funcname}}__prepend_arrayc_with(
        Vec_{{typename}} * const xs,
        ArrayC_{{typename}} const ext,
        void ( * const copier )( {{type}} * to, {{type}} from ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            arrayc_{{funcname}}__is_valid( ext ) );

    return vec_{{funcname}}__insert_arrayc_with(
               xs, xs->length, ext, copier );
}


{{type}} *
vec_{{funcname}}__prepend_arraym(
        Vec_{{typename}} * const xs,
        ArrayM_{{typename}} const ext )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            arraym_{{funcname}}__is_valid( ext ) );

    return vec_{{funcname}}__prepend_arraym_with( xs, ext, NULL );
}


{{type}} *
vec_{{funcname}}__prepend_arraym_with(
        Vec_{{typename}} * const xs,
        ArrayM_{{typename}} const ext,
        void ( * const copier )( {{type}} * to, {{type}} from ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            arraym_{{funcname}}__is_valid( ext ) );

    return vec_{{funcname}}__prepend_arrayc_with(
               xs, arrayc_{{funcname}}__view_arraym( ext ), copier );
}


{{type}} *
vec_{{funcname}}__prepend_vec(
        Vec_{{typename}} * const xs,
        Vec_{{typename}} const ext )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            vec_{{funcname}}__is_valid( ext ) );

    return vec_{{funcname}}__prepend_vec_with( xs, ext, NULL );
}


{{type}} *
vec_{{funcname}}__prepend_vec_with(
        Vec_{{typename}} * const xs,
        Vec_{{typename}} const ext,
        void ( * const copier )( {{type}} * to, {{type}} from ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            vec_{{funcname}}__is_valid( ext ) );

    return vec_{{funcname}}__prepend_arrayc_with(
               xs, arrayc_{{funcname}}__view_vec( ext ), copier );
}


{{type}}
vec_{{funcname}}__remove(
        Vec_{{typename}} * const xs,
        size_t const ix )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            ix < xs->length );

    {{type}} const x = vec_{{funcname}}__get( *xs, ix );
    for ( size_t i = ix + 1; i < xs->length; i++ ) {
        xs->e[ i - 1 ] = xs->e[ i ];
    }
    xs->length--;
    return x;
}


{{type}}
vec_{{funcname}}__remove_with(
        Vec_{{typename}} * const xs,
        size_t const ix,
        void ( * const freer )( {{type}} * x ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            ix < xs->length );

    {{type}} * const x = vec_{{funcname}}__getp( *xs, ix );
    for ( size_t i = ix + 1; i < xs->length; i++ ) {
        xs->e[ i - 1 ] = xs->e[ i ];
    }
    xs->length--;
    if ( freer != NULL ) {
        freer( x );
    }
    return *x;
}


{{type}}
vec_{{funcname}}__pop(
        Vec_{{typename}} * const xs )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ), xs->length > 0 );

    return vec_{{funcname}}__pop_with( xs, NULL );
}


{{type}}
vec_{{funcname}}__pop_with(
        Vec_{{typename}} * const xs,
        void ( * const freer )( {{type}} * x ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ), xs->length > 0 );

    return vec_{{funcname}}__remove_with( xs, xs->length - 1, freer );
}


void
vec_{{funcname}}__popn(
        Vec_{{typename}} * const xs,
        size_t const n )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    xs->length = size__sub_b( xs->length, n );
}


void
vec_{{funcname}}__popn_with(
        Vec_{{typename}} * const xs,
        size_t const n,
        void ( * const freer )( {{type}} * ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    vec_{{funcname}}__eachp( vec_{{funcname}}__take_end( *xs, n ),
                             .f = freer );
    xs->length = size__sub_b( xs->length, n );
}


{{type}}
vec_{{funcname}}__first(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            vec_{{funcname}}__isnt_empty( xs ) );

    return arrayc_{{funcname}}__first( arrayc_{{funcname}}__view_vec( xs ) );
}


{{type}} *
vec_{{funcname}}__firstp(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__firstp( arraym_{{funcname}}__view_vec( xs ) );
}


Maybe_{{typename}}
vec_{{funcname}}__firstm(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__firstm( arrayc_{{funcname}}__view_vec( xs ) );
}


{{type}}
vec_{{funcname}}__last(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            vec_{{funcname}}__isnt_empty( xs ) );

    return arrayc_{{funcname}}__last( arrayc_{{funcname}}__view_vec( xs ) );
}


{{type}} *
vec_{{funcname}}__lastp(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__lastp( arraym_{{funcname}}__view_vec( xs ) );
}


Maybe_{{typename}}
vec_{{funcname}}__lastm(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__lastm( arrayc_{{funcname}}__view_vec( xs ) );
}


size_t
vec_{{funcname}}__count(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__count(
               arrayc_{{funcname}}__view_vec( xs ), f );
}


size_t
vec_{{funcname}}__count_first(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__count_first(
               arrayc_{{funcname}}__view_vec( xs ), f );
}


size_t
vec_{{funcname}}__count_last(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__count_last(
               arrayc_{{funcname}}__view_vec( xs ), f );
}


Vec_{{typename}}
vec_{{funcname}}__take(
        Vec_{{typename}} const xs,
        size_t const n )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return xs;
    } else {
        return ( Vec_{{typename}} ){
                   .e        = xs.e,
                   .length   = n,
                   .capacity = xs.capacity };
    }
}


Vec_{{typename}}
vec_{{funcname}}__drop(
        Vec_{{typename}} const xs,
        size_t const n )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return ( Vec_{{typename}} ){ 0 };
    } else {
        return ( Vec_{{typename}} ){
                   .e        = xs.e + n,
                   .length   = xs.length - n,
                   .capacity = xs.capacity - n };
    }
}


Vec_{{typename}}
vec_{{funcname}}__take_end(
        Vec_{{typename}} const xs,
        size_t const n )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return xs;
    } else {
        return vec_{{funcname}}__drop( xs, xs.length - n );
    }
}


Vec_{{typename}}
vec_{{funcname}}__drop_end(
        Vec_{{typename}} const xs,
        size_t const n )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return ( Vec_{{typename}} ){ 0 };
    } else {
        return vec_{{funcname}}__take( xs, xs.length - n );
    }
}


Vec_{{typename}}
vec_{{funcname}}__take_while(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return vec_{{funcname}}__take(
               xs,
               vec_{{funcname}}__count_first( xs, f ) );
}


Vec_{{typename}}
vec_{{funcname}}__take_end_while(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return vec_{{funcname}}__take_end(
               xs,
               vec_{{funcname}}__count_last( xs, f ) );
}


Vec_{{typename}}
vec_{{funcname}}__drop_while(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return vec_{{funcname}}__drop(
               xs,
               vec_{{funcname}}__count_first( xs, f ) );
}


Vec_{{typename}}
vec_{{funcname}}__drop_end_while(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return vec_{{funcname}}__drop_end(
               xs,
               vec_{{funcname}}__count_last( xs, f ) );
}


Vec_{{typename}}
vec_{{funcname}}__slice(
        Vec_{{typename}} const xs,
        size_t const start,
        size_t const stop )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__drop(
               vec_{{funcname}}__take( xs, stop ),
               start );
}


Vec_{{typename}}
vec_{{funcname}}__slice_s(
        Vec_{{typename}} const xs,
        intmax_t const start,
        intmax_t const stop )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__slice(
               xs,
               normalize_index( start, xs.length ),
               normalize_index( stop, xs.length ) );
}


Vec_{{typename}}
vec_{{funcname}}__left_half(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__take( xs, xs.length / 2 );
}


Vec_{{typename}}
vec_{{funcname}}__right_half(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__drop( xs, xs.length / 2 );
}


Vec_{{typename}}
vec_{{funcname}}__view_whole(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    Vec_{{typename}} v = xs;
    v.length = xs.capacity;
    return v;
}


Vec_{{typename}}
vec_{{funcname}}__view_spare(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__take_end(
               vec_{{funcname}}__view_whole( xs ),
               vec_{{funcname}}__spare_capacity( xs ) );
}


Maybe_size
vec_{{funcname}}__find(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__find(
               arrayc_{{funcname}}__view_vec( xs ), f );
}


Maybe_size
vec_{{funcname}}__find_not(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__find_not(
               arrayc_{{funcname}}__view_vec( xs ), f );
}


Maybe_size
vec_{{funcname}}__find_last(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__find_last(
               arrayc_{{funcname}}__view_vec( xs ), f );
}


Maybe_size
vec_{{funcname}}__find_last_not(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__find_last_not(
               arrayc_{{funcname}}__view_vec( xs ), f );
}


{{type}} *
vec_{{funcname}}__findp(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arraym_{{funcname}}__findp(
               arraym_{{funcname}}__view_vec( xs ), f );
}


{{type}} *
vec_{{funcname}}__findp_not(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arraym_{{funcname}}__findp_not(
               arraym_{{funcname}}__view_vec( xs ), f );
}


{{type}} *
vec_{{funcname}}__findp_last(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arraym_{{funcname}}__findp_last(
               arraym_{{funcname}}__view_vec( xs ), f );
}


{{type}} *
vec_{{funcname}}__findp_last_not(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arraym_{{funcname}}__findp_last_not(
               arraym_{{funcname}}__view_vec( xs ), f );
}


Maybe_{{typename}}
vec_{{funcname}}__findm(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__findm(
               arrayc_{{funcname}}__view_vec( xs ), f );
}


Maybe_{{typename}}
vec_{{funcname}}__findm_not(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__findm_not(
               arrayc_{{funcname}}__view_vec( xs ), f );
}


Maybe_{{typename}}
vec_{{funcname}}__findm_last(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__findm_last(
               arrayc_{{funcname}}__view_vec( xs ), f );
}


Maybe_{{typename}}
vec_{{funcname}}__findm_last_not(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__findm_last_not(
               arrayc_{{funcname}}__view_vec( xs ), f );
}


bool
vec_{{funcname}}__any(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__any(
               arrayc_{{funcname}}__view_vec( xs ), f );
}


bool
vec_{{funcname}}__all(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__all(
               arrayc_{{funcname}}__view_vec( xs ), f );
}


bool
vec_{{funcname}}__only_one(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__only_one(
               arrayc_{{funcname}}__view_vec( xs ), f );
}


bool
vec_{{funcname}}__all_but_one(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__all_but_one(
               arrayc_{{funcname}}__view_vec( xs ), f );
}


{{type}}
vec_{{funcname}}__foldl(
        Vec_{{typename}} const xs,
        {{type}} const init,
        {{type}} ( * const f )( {{type}} acc, {{type}} x ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__foldl(
               arrayc_{{funcname}}__view_vec( xs ), init, f );
}


{{type}}
vec_{{funcname}}__foldl1(
        Vec_{{typename}} xs,
        {{type}} ( * f )( {{type}} acc, {{type}} x ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), xs.length > 0, f != NULL );

    return arrayc_{{funcname}}__foldl1(
               arrayc_{{funcname}}__view_vec( xs ), f );
}


{{type}}
vec_{{funcname}}__foldr(
        Vec_{{typename}} xs,
        {{type}} init,
        {{type}} ( * f )( {{type}} x, {{type}} acc ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__foldr(
               arrayc_{{funcname}}__view_vec( xs ), init, f );
}


{{type}}
vec_{{funcname}}__foldr1(
        Vec_{{typename}} xs,
        {{type}} ( * f )( {{type}} x, {{type}} acc ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), xs.length > 0, f != NULL );

    return arrayc_{{funcname}}__foldr1(
               arrayc_{{funcname}}__view_vec( xs ), f );
}


{{type}} *
vec_{{funcname}}__pick(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} const * pick, {{type}} x ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    return arraym_{{funcname}}__pick(
               arraym_{{funcname}}__view_vec( xs ), f );
}


bool
vec_{{funcname}}__equal_by(
        Vec_{{typename}} const xs,
        Vec_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            vec_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return arrayc_{{funcname}}__equal_by(
               arrayc_{{funcname}}__view_vec( xs ),
               arrayc_{{funcname}}__view_vec( ys ),
               eq );
}


bool
vec_{{funcname}}__equal_arrayc_by(
        Vec_{{typename}} const xs,
        ArrayC_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return arrayc_{{funcname}}__equal_by(
               arrayc_{{funcname}}__view_vec( xs ), ys, eq );
}


bool
vec_{{funcname}}__has_prefix_by(
        Vec_{{typename}} const xs,
        ArrayC_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return arrayc_{{funcname}}__has_prefix_by(
               arrayc_{{funcname}}__view_vec( xs ), ys, eq );
}


bool
vec_{{funcname}}__has_suffix_by(
        Vec_{{typename}} const xs,
        ArrayC_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return arrayc_{{funcname}}__has_suffix_by(
               arrayc_{{funcname}}__view_vec( xs ), ys, eq );
}


bool
vec_{{funcname}}__has_infix_by(
        Vec_{{typename}} const xs,
        ArrayC_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return arrayc_{{funcname}}__has_infix_by(
               arrayc_{{funcname}}__view_vec( xs ), ys, eq );
}


Maybe_size
vec_{{funcname}}__infix_index_by(
        Vec_{{typename}} const xs,
        ArrayC_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return arrayc_{{funcname}}__infix_index_by(
               arrayc_{{funcname}}__view_vec( xs ), ys, eq );
}


Maybe_size
vec_{{funcname}}__last_infix_index_by(
        Vec_{{typename}} const xs,
        ArrayC_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return arrayc_{{funcname}}__last_infix_index_by(
               arrayc_{{funcname}}__view_vec( xs ), ys, eq );
}


size_t
vec_{{funcname}}__infix_count_by(
        Vec_{{typename}} const xs,
        ArrayC_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return arrayc_{{funcname}}__infix_count_by(
               arrayc_{{funcname}}__view_vec( xs ), ys, eq );
}


bool
vec_{{funcname}}__elem_by(
        Vec_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), eq != NULL );

    return arrayc_{{funcname}}__elem_by(
               arrayc_{{funcname}}__view_vec( xs ), y, eq );
}


Maybe_size
vec_{{funcname}}__elem_index_by(
        Vec_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), eq != NULL );

    return arrayc_{{funcname}}__elem_index_by(
               arrayc_{{funcname}}__view_vec( xs ), y, eq );
}


{{type}} *
vec_{{funcname}}__elem_ptr_by(
        Vec_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), eq != NULL );

    return arraym_{{funcname}}__elem_ptr_by(
               arraym_{{funcname}}__view_vec( xs ), y, eq );
}


Maybe_size
vec_{{funcname}}__elem_last_index_by(
        Vec_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), eq != NULL );

    return arrayc_{{funcname}}__elem_last_index_by(
               arrayc_{{funcname}}__view_vec( xs ), y, eq );
}


{{type}} *
vec_{{funcname}}__elem_last_ptr_by(
        Vec_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), eq != NULL );

    return arraym_{{funcname}}__elem_last_ptr_by(
               arraym_{{funcname}}__view_vec( xs ), y, eq );
}


size_t
vec_{{funcname}}__elem_count_by(
        Vec_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), eq != NULL );

    return arrayc_{{funcname}}__elem_count_by(
               arrayc_{{funcname}}__view_vec( xs ), y, eq );
}


{{type}} *
vec_{{funcname}}__elem_or_append_by(
        Vec_{{typename}} * const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( vec_{{funcname}}__is_valid( *xs ), eq != NULL );

    {{type}} * const p = vec_{{funcname}}__elem_ptr_by( *xs, y, eq );
    if ( p == NULL ) {
        return vec_{{funcname}}__append( xs, y );
    } else {
        return p;
    }
}


void
vec_{{funcname}}__replacef(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} x ),
        {{type}} const repl )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    arraym_{{funcname}}__replacef(
        arraym_{{funcname}}__view_vec( xs ), f, repl );
}


Vec_{{typename}}
vec_{{funcname}}__replacedf(
        Vec_{{typename}} const xs,
        bool ( * const f )( {{type}} x ),
        {{type}} const repl )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), f != NULL );

    errno = 0;
    Vec_{{typename}} const new = vec_{{funcname}}__copy_vec( xs );
    if ( errno ) { return ( Vec_{{typename}} ){ 0 }; }
    vec_{{funcname}}__replacef( new, f, repl );
    return new;
}


void
vec_{{funcname}}__replace_by(
        Vec_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl,
        bool ( * const eq )( {{type}} x, {{type}} el ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), eq != NULL );

    arraym_{{funcname}}__replace_by(
        arraym_{{funcname}}__view_vec( xs ), el, repl, eq );
}


Vec_{{typename}}
vec_{{funcname}}__replaced_by(
        Vec_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl,
        bool ( * const eq )( {{type}} x, {{type}} el ) )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ), eq != NULL );

    errno = 0;
    Vec_{{typename}} const new = vec_{{funcname}}__copy_vec( xs );
    if ( errno ) { return ( Vec_{{typename}} ){ 0 }; }
    vec_{{funcname}}__replace_by( new, el, repl, eq );
    return new;
}


size_t
vec_{{funcname}}__replacef_arrayc(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}} x ),
        ArrayC_{{typename}} const repl )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            f != NULL,
            arrayc_{{funcname}}__is_valid( repl ) );

    return vec_{{funcname}}__replacef_arrayc_with( xs, f, repl, NULL, NULL );
}


size_t
vec_{{funcname}}__replacef_arrayc_with(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}} x ),
        ArrayC_{{typename}} const repl,
        void ( * const copier )( {{type}} * to, {{type}} from ),
        void ( * const freer )( {{type}} * x ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            f != NULL,
            arrayc_{{funcname}}__is_valid( repl ) );

    size_t nrepl = 0;
    size_t offset = 0;
    Maybe_size mi = { .value = 0 };
    // Find an index in `xs` satisfying `f` past the previously-found index and
    // the consequently-inserted replacement (so that we don't replace any
    // elements inserted from the replacement array):
    while ( mi = vec_{{funcname}}__find(
                     vec_{{funcname}}__drop( *xs, offset ), f ),
            !mi.nothing ) {
        // `xs` can't be larger than `SIZE_MAX`, so:
        ASSERT( size__can_add( mi.value, offset ) );
        mi.value += offset; // offsets the `drop()` call above
        // Remove the found element satisfying `f`:
        vec_{{funcname}}__remove_with( xs, mi.value, freer );
        if ( errno ) { return nrepl; }
        // Now insert the replacement array at that index:
        vec_{{funcname}}__insert_arrayc_with( xs, mi.value, repl, copier );
        if ( errno ) { return nrepl; }
        // Insertion didn't fail, so:
        ASSERT( size__can_add( mi.value, repl.length ) );
        offset = mi.value + repl.length;
        nrepl++;
    }
    return nrepl;
}


size_t
vec_{{funcname}}__replacef_arraym(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}} x ),
        ArrayM_{{typename}} const repl )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            f != NULL,
            arraym_{{funcname}}__is_valid( repl ) );

    return vec_{{funcname}}__replacef_arraym_with( xs, f, repl, NULL, NULL );
}


size_t
vec_{{funcname}}__replacef_arraym_with(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}} x ),
        ArrayM_{{typename}} const repl,
        void ( * const copier )( {{type}} * to, {{type}} from ),
        void ( * const freer )( {{type}} * x ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            f != NULL,
            arraym_{{funcname}}__is_valid( repl ) );

    return vec_{{funcname}}__replacef_arrayc_with(
               xs, f, arrayc_{{funcname}}__view_arraym( repl ),
               copier, freer );
}


size_t
vec_{{funcname}}__replacef_vec(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}} x ),
        Vec_{{typename}} const repl )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            f != NULL,
            vec_{{funcname}}__is_valid( repl ) );

    return vec_{{funcname}}__replacef_vec_with( xs, f, repl, NULL, NULL );
}


size_t
vec_{{funcname}}__replacef_vec_with(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}} x ),
        Vec_{{typename}} const repl,
        void ( * const copier )( {{type}} * to, {{type}} from ),
        void ( * const freer )( {{type}} * x ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            f != NULL,
            vec_{{funcname}}__is_valid( repl ) );

    return vec_{{funcname}}__replacef_arrayc_with(
               xs, f, arrayc_{{funcname}}__view_vec( repl ), copier, freer );
}


size_t
vec_{{funcname}}__replace_arrayc_by(
        Vec_{{typename}} * const xs,
        {{type}} const el,
        ArrayC_{{typename}} const repl,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            arrayc_{{funcname}}__is_valid( repl ) );

    return vec_{{funcname}}__replace_arrayc_by_with(
               xs, el, repl, eq, NULL, NULL );
}


size_t
vec_{{funcname}}__replace_arrayc_by_with(
        Vec_{{typename}} * const xs,
        {{type}} const el,
        ArrayC_{{typename}} const repl,
        bool ( * const eq )( {{type}} x, {{type}} y ),
        void ( * const copier )( {{type}} * to, {{type}} from ),
        void ( * const freer )( {{type}} * x ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            arrayc_{{funcname}}__is_valid( repl ) );

    size_t nrepl = 0;
    size_t offset = 0;
    Maybe_size mi = { .value = 0 };
    // Find an index in `xs` satisfying `f` past the previously-found index and
    // the consequently-inserted replacement (so that we don't replace any
    // elements inserted from the replacement array):
    while ( mi = vec_{{funcname}}__elem_index_by(
                     vec_{{funcname}}__drop( *xs, offset ), el, eq ),
            !mi.nothing ) {
        // `xs` can't be larger than `SIZE_MAX`, so:
        ASSERT( size__can_add( mi.value, offset ) );
        mi.value += offset; // offsets the `drop()` call above
        // Remove the found element equal to `el` under `eq`:
        vec_{{funcname}}__remove_with( xs, mi.value, freer );
        if ( errno ) { return nrepl; }
        // Now insert the replacement array at that index:
        vec_{{funcname}}__insert_arrayc_with( xs, mi.value, repl, copier );
        if ( errno ) { return nrepl; }
        // Insertion didn't fail, so:
        ASSERT( size__can_add( mi.value, repl.length ) );
        offset = mi.value + repl.length;
        nrepl++;
    }
    return nrepl;
}


size_t
vec_{{funcname}}__replace_arraym_by(
        Vec_{{typename}} * const xs,
        {{type}} const el,
        ArrayM_{{typename}} const repl,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            arraym_{{funcname}}__is_valid( repl ) );

    return vec_{{funcname}}__replace_arraym_by_with(
               xs, el, repl, eq, NULL, NULL );
}


size_t
vec_{{funcname}}__replace_arraym_by_with(
        Vec_{{typename}} * const xs,
        {{type}} const el,
        ArrayM_{{typename}} const repl,
        bool ( * const eq )( {{type}} x, {{type}} y ),
        void ( * const copier )( {{type}} * to, {{type}} from ),
        void ( * const freer )( {{type}} * x ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            arraym_{{funcname}}__is_valid( repl ) );

    return vec_{{funcname}}__replace_arrayc_by_with(
               xs, el, arrayc_{{funcname}}__view_arraym( repl ), eq,
               copier, freer );
}


size_t
vec_{{funcname}}__replace_vec_by(
        Vec_{{typename}} * const xs,
        {{type}} const el,
        Vec_{{typename}} const repl,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            vec_{{funcname}}__is_valid( repl ) );

    return vec_{{funcname}}__replace_vec_by_with(
               xs, el, repl, eq, NULL, NULL );
}


size_t
vec_{{funcname}}__replace_vec_by_with(
        Vec_{{typename}} * const xs,
        {{type}} const el,
        Vec_{{typename}} const repl,
        bool ( * const eq )( {{type}} x, {{type}} y ),
        void ( * const copier )( {{type}} * to, {{type}} from ),
        void ( * const freer )( {{type}} * x ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            vec_{{funcname}}__is_valid( repl ) );

    return vec_{{funcname}}__replace_arrayc_by_with(
               xs, el, arrayc_{{funcname}}__view_vec( repl ), eq,
               copier, freer );
}


static
void
filter(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}} ),
        bool const result,
        void ( * const freer )( {{type}} * ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ), f != NULL );

    size_t count = 0;
    for ( size_t i = 0; i < xs->length; i++ ) {
        {{type}} * const count_el = vec_{{funcname}}__getp( *xs, count );
        {{type}} const i_el = vec_{{funcname}}__get( *xs, i );
        if ( f( i_el ) != result ) {
            // Don't free the `count`th element if it's the `i`th element:
            if ( count != i && freer != NULL ) {
                freer( count_el );
            }
            *count_el = i_el;
            count++;
        }
    }
    xs->length = count;
}


void
vec_{{funcname}}__filter(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ), f != NULL );

    filter( xs, f, true, NULL );
}


void
vec_{{funcname}}__filter_with(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}} ),
        void ( * const freer )( {{type}} * ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ), f != NULL );

    filter( xs, f, true, freer );
}


void
vec_{{funcname}}__filter_not(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ), f != NULL );

    filter( xs, f, false, NULL );
}


void
vec_{{funcname}}__filter_not_with(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}} ),
        void ( * const freer )( {{type}} * ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ), f != NULL );

    filter( xs, f, false, freer );
}


static
void
filterv(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}}, void * ptr ),
        void * const ptr,
        bool const result,
        void ( * const freer )( {{type}} * ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ), f != NULL );

    size_t count = 0;
    for ( size_t i = 0; i < xs->length; i++ ) {
        {{type}} * const count_el = vec_{{funcname}}__getp( *xs, count );
        {{type}} const i_el = vec_{{funcname}}__get( *xs, i );
        if ( f( i_el, ptr ) != result ) {
            // Don't free the `count`th element if it's the `i`th element:
            if ( count != i && freer != NULL ) {
                freer( count_el );
            }
            *count_el = i_el;
            count++;
        }
    }
    xs->length = count;
}


void
vec_{{funcname}}__filterv(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}}, void * ptr ),
        void * const ptr )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ), f != NULL );

    filterv( xs, f, ptr, true, NULL );
}


void
vec_{{funcname}}__filterv_with(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}}, void * ptr ),
        void * const ptr,
        void ( * const freer )( {{type}} * ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ), f != NULL );

    filterv( xs, f, ptr, true, freer );
}


void
vec_{{funcname}}__filterv_not(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}}, void * ptr ),
        void * const ptr )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ), f != NULL );

    filterv( xs, f, ptr, false, NULL );
}


void
vec_{{funcname}}__filterv_not_with(
        Vec_{{typename}} * const xs,
        bool ( * const f )( {{type}}, void * ptr ),
        void * const ptr,
        void ( * const freer )( {{type}} * ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ), f != NULL );

    filterv( xs, f, ptr, false, freer );
}


bool
vec_{{funcname}}__each_(
        Vec_{{typename}} const xs,
        struct vec_{{funcname}}__each__options const o )
{
    return arrayc_{{funcname}}__each(
               arrayc_{{funcname}}__view_vec( xs ),
               .f = o.f, .b = o.b, .fi = o.fi, .bi = o.bi,
               .fv = o.fv, .bv = o.bv, .fvi = o.fvi, .bvi = o.bvi,
               .where = o.where, .where_not = o.where_not,
               .v = o.v );
}


bool
vec_{{funcname}}__eachp_(
        Vec_{{typename}} const xs,
        struct vec_{{funcname}}__eachp__options const o )
{
    return arraym_{{funcname}}__eachp(
               arraym_{{funcname}}__view_vec( xs ),
               .f = o.f, .b = o.b, .fi = o.fi, .bi = o.bi,
               .fv = o.fv, .bv = o.bv, .fvi = o.fvi, .bvi = o.bvi,
               .where = o.where, .where_not = o.where_not,
               .v = o.v );
}


ArrayC_{{typename}}
arrayc_{{funcname}}__view_vec(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__view_arraym(
               arraym_{{funcname}}__view_vec( xs ) );
}


ArrayC_{{typename}}
arrayc_{{funcname}}__view_vec_whole(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__view_arraym(
               arraym_{{funcname}}__view_vec_whole( xs ) );
}


ArrayC_{{typename}}
arrayc_{{funcname}}__view_vec_spare(
        Vec_{{typename}} const xs )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__view_arraym(
               arraym_{{funcname}}__view_vec_spare( xs ) );
}


ArrayM_{{typename}}
arraym_{{funcname}}__view_vec(
        Vec_{{typename}} const xs )
{
    return ( ArrayM_{{typename}} ){ .e = xs.e, .length = xs.length };
}


ArrayM_{{typename}}
arraym_{{funcname}}__view_vec_whole(
        Vec_{{typename}} const xs )
{
    return arraym_{{funcname}}__view_vec(
               vec_{{funcname}}__view_whole( xs ) );
}


ArrayM_{{typename}}
arraym_{{funcname}}__view_vec_spare(
        Vec_{{typename}} const xs )
{
    return arraym_{{funcname}}__view_vec(
               vec_{{funcname}}__view_spare( xs ) );
}


ArrayM_{{typename}}
arraym_{{funcname}}__copy_vec(
        Vec_{{typename}} const xs )
{
    return arraym_{{funcname}}__copy_arraym(
               arraym_{{funcname}}__view_vec( xs ) );
}


ArrayM_{{typename}}
arraym_{{funcname}}__copy_vec_whole(
        Vec_{{typename}} const xs )
{
    return arraym_{{funcname}}__copy_arrayc(
               arrayc_{{funcname}}__view_vec_whole( xs ) );
}




{% if 'EQ' in typeclasses %}


static
bool
equalf(
        {{type}} const x,
        {{type}} const y )
{
    // Might be a macro, so:
    return {{funcname}}__equal( x, y );
}


bool
vec_{{funcname}}__equal(
        Vec_{{typename}} const xs,
        Vec_{{typename}} const ys )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            vec_{{funcname}}__is_valid( ys ) );

    return vec_{{funcname}}__equal_by( xs, ys, equalf );
}


bool
vec_{{funcname}}__not_equal(
        Vec_{{typename}} const xs,
        Vec_{{typename}} const ys )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ),
            vec_{{funcname}}__is_valid( ys ) );

    return !vec_{{funcname}}__equal( xs, ys );
}


bool
vec_{{funcname}}__first_is(
        Vec_{{typename}} const v,
        {{type}} const el )
{
    ASSERT( vec_{{funcname}}__is_valid( v ) );

    return arrayc_{{funcname}}__first_is(
               arrayc_{{funcname}}__view_vec( v ), el );
}


bool
vec_{{funcname}}__last_is(
        Vec_{{typename}} const v,
        {{type}} const el )
{
    ASSERT( vec_{{funcname}}__is_valid( v ) );

    return arrayc_{{funcname}}__last_is(
               arrayc_{{funcname}}__view_vec( v ), el );
}


bool
vec_{{funcname}}__has_prefix(
        Vec_{{typename}} const v,
        ArrayC_{{typename}} const prefix )
{
    ASSERT( vec_{{funcname}}__is_valid( v ),
            arrayc_{{funcname}}__is_valid( prefix ) );

    return vec_{{funcname}}__has_prefix_by( v, prefix, equalf );
}


bool
vec_{{funcname}}__has_suffix(
        Vec_{{typename}} const v,
        ArrayC_{{typename}} const suffix )
{
    ASSERT( vec_{{funcname}}__is_valid( v ),
            arrayc_{{funcname}}__is_valid( suffix ) );

    return vec_{{funcname}}__has_suffix_by( v, suffix, equalf );
}


bool
vec_{{funcname}}__has_infix(
        Vec_{{typename}} const v,
        ArrayC_{{typename}} const infix )
{
    ASSERT( vec_{{funcname}}__is_valid( v ),
            arrayc_{{funcname}}__is_valid( infix ) );

    return vec_{{funcname}}__has_infix_by( v, infix, equalf );
}


Maybe_size
vec_{{funcname}}__infix_index(
        Vec_{{typename}} const v,
        ArrayC_{{typename}} const infix )
{
    ASSERT( vec_{{funcname}}__is_valid( v ),
            arrayc_{{funcname}}__is_valid( infix ) );

    return vec_{{funcname}}__infix_index_by( v, infix, equalf );
}


Maybe_size
vec_{{funcname}}__last_infix_index(
        Vec_{{typename}} const v,
        ArrayC_{{typename}} const infix )
{
    ASSERT( vec_{{funcname}}__is_valid( v ),
            arrayc_{{funcname}}__is_valid( infix ) );

    return vec_{{funcname}}__last_infix_index_by( v, infix, equalf );
}


size_t
vec_{{funcname}}__infix_count(
        Vec_{{typename}} const v,
        ArrayC_{{typename}} const infix )
{
    ASSERT( vec_{{funcname}}__is_valid( v ),
            arrayc_{{funcname}}__is_valid( infix ) );

    return vec_{{funcname}}__infix_count_by( v, infix, equalf );
}


bool
vec_{{funcname}}__elem(
        Vec_{{typename}} const xs,
        {{type}} const y )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__elem_by( xs, y, equalf );
}


Maybe_size
vec_{{funcname}}__elem_index(
        Vec_{{typename}} const xs,
        {{type}} const y )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__elem_index_by( xs, y, equalf );
}


{{type}} *
vec_{{funcname}}__elem_ptr(
        Vec_{{typename}} const xs,
        {{type}} const y )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__elem_ptr_by( xs, y, equalf );
}


Maybe_size
vec_{{funcname}}__elem_last_index(
        Vec_{{typename}} const xs,
        {{type}} const y )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__elem_last_index_by( xs, y, equalf );
}


{{type}} *
vec_{{funcname}}__elem_last_ptr(
        Vec_{{typename}} const xs,
        {{type}} const y )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__elem_last_ptr_by( xs, y, equalf );
}


size_t
vec_{{funcname}}__elem_count(
        Vec_{{typename}} const xs,
        {{type}} const y )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__elem_count_by( xs, y, equalf );
}


{{type}} *
vec_{{funcname}}__elem_or_append(
        Vec_{{typename}} * const xs,
        {{type}} const y )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ) );

    return vec_{{funcname}}__elem_or_append_by( xs, y, equalf );
}


void
vec_{{funcname}}__replace(
        Vec_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    vec_{{funcname}}__replace_by( xs, el, repl, equalf );
}


Vec_{{typename}}
vec_{{funcname}}__replaced(
        Vec_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl )
{
    ASSERT( vec_{{funcname}}__is_valid( xs ) );

    return vec_{{funcname}}__replaced_by( xs, el, repl, equalf );
}


size_t
vec_{{funcname}}__replace_arrayc(
        Vec_{{typename}} * const xs,
        {{type}} const el,
        ArrayC_{{typename}} const repl )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            arrayc_{{funcname}}__is_valid( repl ) );

    return vec_{{funcname}}__replace_arrayc_with(
               xs, el, repl, NULL, NULL );
}


size_t
vec_{{funcname}}__replace_arrayc_with(
        Vec_{{typename}} * const xs,
        {{type}} const el,
        ArrayC_{{typename}} const repl,
        void ( * const copier )( {{type}} * to, {{type}} from ),
        void ( * const freer )( {{type}} * x ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            arrayc_{{funcname}}__is_valid( repl ) );

    return vec_{{funcname}}__replace_arrayc_by_with(
               xs, el, repl, equalf, copier, freer );
}


size_t
vec_{{funcname}}__replace_arraym(
        Vec_{{typename}} * const xs,
        {{type}} const el,
        ArrayM_{{typename}} const repl )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            arraym_{{funcname}}__is_valid( repl ) );

    return vec_{{funcname}}__replace_arraym_with(
               xs, el, repl, NULL, NULL );
}


size_t
vec_{{funcname}}__replace_arraym_with(
        Vec_{{typename}} * const xs,
        {{type}} const el,
        ArrayM_{{typename}} const repl,
        void ( * const copier )( {{type}} * to, {{type}} from ),
        void ( * const freer )( {{type}} * x ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            arraym_{{funcname}}__is_valid( repl ) );

    return vec_{{funcname}}__replace_arraym_by_with(
               xs, el, repl, equalf, copier, freer );
}


size_t
vec_{{funcname}}__replace_vec(
        Vec_{{typename}} * const xs,
        {{type}} const el,
        Vec_{{typename}} const repl )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            vec_{{funcname}}__is_valid( repl ) );

    return vec_{{funcname}}__replace_vec_with(
               xs, el, repl, NULL, NULL );
}


size_t
vec_{{funcname}}__replace_vec_with(
        Vec_{{typename}} * const xs,
        {{type}} const el,
        Vec_{{typename}} const repl,
        void ( * const copier )( {{type}} * to, {{type}} from ),
        void ( * const freer )( {{type}} * x ) )
{
    ASSERT( xs != NULL, vec_{{funcname}}__is_valid( *xs ),
            vec_{{funcname}}__is_valid( repl ) );

    return vec_{{funcname}}__replace_vec_by_with(
               xs, el, repl, equalf, copier, freer );
}


{% endif %} {# EQ #}




{% if 'NULL' in typeclasses %}


Vec_{{typename}}
vec_{{funcname}}__view_buf(
        {{type}} * const buf )
{
    return vec_{{funcname}}__view_arraym(
               arraym_{{funcname}}__view_buf( buf ) );
}


Vec_{{typename}}
vec_{{funcname}}__view_buf0(
        {{type}} * const buf )
{
    return vec_{{funcname}}__view_arraym(
               arraym_{{funcname}}__view_buf0( buf ) );
}


bool
vec_{{funcname}}__last_is_null(
        Vec_{{typename}} const v )
{
    ASSERT( vec_{{funcname}}__is_valid( v ) );

    return arrayc_{{funcname}}__last_is_null(
               arrayc_{{funcname}}__view_vec( v ) );
}


bool
vec_{{funcname}}__all_null(
        Vec_{{typename}} const v )
{
    ASSERT( vec_{{funcname}}__is_valid( v ) );

    return arrayc_{{funcname}}__all_null(
               arrayc_{{funcname}}__view_vec( v ) );
}


void
vec_{{funcname}}__append_null(
        Vec_{{typename}} * const v )
{
    ASSERT( v != NULL, vec_{{funcname}}__is_valid( *v ) );

    vec_{{funcname}}__append( v, {{funcname}}__null() );
}


void
vec_{{funcname}}__term_null(
        Vec_{{typename}} * const v )
{
    ASSERT( v != NULL, vec_{{funcname}}__is_valid( *v ) );

    if ( !vec_{{funcname}}__last_is_null( *v ) ) {
        vec_{{funcname}}__append_null( v );
    }
}


bool
vec_{{funcname}}__pop_null(
        Vec_{{typename}} * const v )
{
    ASSERT( v != NULL, vec_{{funcname}}__is_valid( *v ) );

    if ( vec_{{funcname}}__last_is_null( *v ) ) {
        vec_{{funcname}}__pop( v );
        return true;
    } else {
        return false;
    }
}


void
vec_{{funcname}}__filter_null(
        Vec_{{typename}} * const v )
{
    ASSERT( v != NULL, vec_{{funcname}}__is_valid( *v ) );

    vec_{{funcname}}__filter( v, {{funcname}}__is_null );
}


{% endif %} {# NULL #}




{% if 'CHAR' in typeclasses %}


#include <stdarg.h>
#include <stdio.h>

#include <libstr/str.h>


Vec_{{typename}}
vec_{{funcname}}__copy_str(
        char const * const str )
{
    return vec_{{funcname}}__view_arraym(
               arraym_{{funcname}}__copy_str( str ) );
}


Vec_{{typename}}
vec_{{funcname}}__copyc_str(
        char const * const str,
        size_t const capacity )
{
    size_t const len = str__length( str );
    Vec_{{typename}} vec = vec_{{funcname}}__new_alloc( MAX( len, capacity ) );
    if ( errno ) { return vec; }
    vec_{{funcname}}__append_str( &vec, str );
    return vec;
}


void
vec_{{funcname}}__copy_str_into(
        Vec_{{typename}} * const to,
        char const * const from )
{
    ASSERT( to != NULL, vec_{{funcname}}__is_valid( *to ) );

    vec_{{funcname}}__empty( to );
    vec_{{funcname}}__append_str( to, from );
}


{{type}} *
vec_{{funcname}}__insert_str(
        Vec_{{typename}} * const v,
        size_t const at,
        char const * const str )
{
    ASSERT( v != NULL, vec_{{funcname}}__is_valid( *v ),
            at <= v->length );

    size_t const len = str__length( str );
    vec_{{funcname}}__grow_capacity_for( v, len );
    if ( errno ) { return NULL; }
    // Growth of `v` didn't fail, so:
    ASSERT( size__can_add( v->length, len ) );
    // Move along the elements of `v` per the length of `ys`:
    for ( size_t i = v->length; i > at; i-- ) {
        v->e[ ( i - 1 ) + len ] = v->e[ i - 1 ];
    }
    v->length += len;
    // Insert the elements of `ys` at `at` (now that they've been moved):
    for ( size_t i = 0; i < len; i++ ) {
        {{type}} * const v_el = vec_{{funcname}}__getp( *v, at + i );
        ASSERT( v_el != NULL );
        char const c = str[ i ];
        *v_el = {{funcname}}__from_char( c );
    }
    return vec_{{funcname}}__getp( *v, at );
}


{{type}} *
vec_{{funcname}}__append_str(
        Vec_{{typename}} * const v,
        char const * const str )
{
    ASSERT( v != NULL, vec_{{funcname}}__is_valid( *v ) );

    return vec_{{funcname}}__insert_str( v, v->length, str );
}


{{type}} *
vec_{{funcname}}__prepend_str(
        Vec_{{typename}} * const v,
        char const * const str )
{
    ASSERT( v != NULL, vec_{{funcname}}__is_valid( *v ) );

    return vec_{{funcname}}__insert_str( v, 0, str );
}


Vec_{{typename}}
vec_{{funcname}}__copy_str0(
        char const * const str )
{
    return vec_{{funcname}}__view_arraym(
               arraym_{{funcname}}__copy_str0( str ) );
}


Vec_{{typename}}
vec_{{funcname}}__copyc_str0(
        char const * const str,
        size_t const capacity )
{
    size_t const sz = str__size( str );
    Vec_{{typename}} vec = vec_{{funcname}}__new_alloc( MAX( sz, capacity ) );
    if ( errno ) { return vec; }
    vec_{{funcname}}__append_str0( &vec, str );
    return vec;
}


void
vec_{{funcname}}__copy_str0_into(
        Vec_{{typename}} * const to,
        char const * const from )
{
    ASSERT( to != NULL, vec_{{funcname}}__is_valid( *to ) );

    vec_{{funcname}}__empty( to );
    vec_{{funcname}}__append_str0( to, from );
}


{{type}} *
vec_{{funcname}}__insert_str0(
        Vec_{{typename}} * const v,
        size_t const at,
        char const * const str )
{
    ASSERT( v != NULL, vec_{{funcname}}__is_valid( *v ),
            at <= v->length );

    size_t const sz = str__size( str );
    vec_{{funcname}}__grow_capacity_for( v, sz );
    if ( errno ) { return NULL; }
    // Growth of `v` didn't fail, so:
    ASSERT( size__can_add( v->length, sz ) );
    // Move along the elements of `v` per the length of `ys`:
    for ( size_t i = v->length; i > at; i-- ) {
        v->e[ ( i - 1 ) + sz ] = v->e[ i - 1 ];
    }
    v->length += sz;
    // Insert the elements of `ys` at `at` (now that they've been moved):
    for ( size_t i = 0; i < sz; i++ ) {
        {{type}} * const v_el = vec_{{funcname}}__getp( *v, at + i );
        ASSERT( v_el != NULL );
        char const c = str[ i ];
        *v_el = {{funcname}}__from_char( c );
    }
    return vec_{{funcname}}__getp( *v, at );
}


{{type}} *
vec_{{funcname}}__append_str0(
        Vec_{{typename}} * const v,
        char const * const str )
{
    ASSERT( v != NULL, vec_{{funcname}}__is_valid( *v ) );

    return vec_{{funcname}}__insert_str0( v, v->length, str );
}


{{type}} *
vec_{{funcname}}__prepend_str0(
        Vec_{{typename}} * const v,
        char const * const str )
{
    ASSERT( v != NULL, vec_{{funcname}}__is_valid( *v ) );

    return vec_{{funcname}}__insert_str0( v, 0, str );
}


Vec_{{typename}}
vec_{{funcname}}__new_fmt(
        char const * const format,
        ... )
{
    ASSERT( format != NULL );

    Vec_{{typename}} v = ( Vec_{{typename}} ){ 0 };
    va_list ap;
    va_start( ap, format );
    errno = 0;
    vec_{{funcname}}__append_fmtv( &v, format, ap );
    int const err = errno;
    va_end( ap );
    if ( err ) { errno = err; }
    return v;
}


void
vec_{{funcname}}__fmt_into(
        Vec_{{typename}} * const v,
        char const * const format,
        ... )
{
    ASSERT( v != NULL, vec_{{funcname}}__is_valid( *v ),
            format != NULL );

    va_list ap;
    va_start( ap, format );
    vec_{{funcname}}__empty( v );
    errno = 0;
    vec_{{funcname}}__append_fmtv( v, format, ap );
    int const err = errno;
    va_end( ap );
    if ( err ) { errno = err; }
}


void
vec_{{funcname}}__append_fmt(
        Vec_{{typename}} * const v,
        char const * const format,
        ... )
{
    ASSERT( v != NULL, vec_{{funcname}}__is_valid( *v ),
            format != NULL );

    va_list ap;
    va_start( ap, format );
    errno = 0;
    vec_{{funcname}}__append_fmtv( v, format, ap );
    int const err = errno;
    va_end( ap );
    if ( err ) { errno = err; }
}


void
vec_{{funcname}}__append_fmtv(
        Vec_{{typename}} * const v,
        char const * const format,
        va_list ap )
{
    ASSERT( v != NULL, vec_{{funcname}}__is_valid( *v ) );

    if ( format == NULL ) { return; }
    char * ext;
    errno = 0;
    // TODO: asprintf is a non-standard GNU/BSD extension to libc; replace
    int const r = vasprintf( &ext, format, ap );
    if ( r < 0 && errno == 0 ) {
        errno = EIO;
    }
    if ( errno ) { return; }
    vec_{{funcname}}__append_str( v, ext );
    int const append_err = errno;
    free( ext );
    if ( append_err ) { errno = append_err; }
}


Vec_{{typename}}
vec_{{funcname}}__new_fmt0(
        char const * const format,
        ... )
{
    ASSERT( format != NULL );

    Vec_{{typename}} v = ( Vec_{{typename}} ){ 0 };
    va_list ap;
    va_start( ap, format );
    errno = 0;
    vec_{{funcname}}__append_fmtv0( &v, format, ap );
    int const err = errno;
    va_end( ap );
    if ( err ) { errno = err; }
    return v;
}


void
vec_{{funcname}}__fmt0_into(
        Vec_{{typename}} * const v,
        char const * const format,
        ... )
{
    ASSERT( v != NULL, vec_{{funcname}}__is_valid( *v ),
            format != NULL );

    va_list ap;
    va_start( ap, format );
    vec_{{funcname}}__empty( v );
    errno = 0;
    vec_{{funcname}}__append_fmtv0( v, format, ap );
    int const err = errno;
    va_end( ap );
    if ( err ) { errno = err; }
}


void
vec_{{funcname}}__append_fmt0(
        Vec_{{typename}} * const v,
        char const * const format,
        ... )
{
    ASSERT( v != NULL, vec_{{funcname}}__is_valid( *v ),
            format != NULL );

    va_list ap;
    va_start( ap, format );
    errno = 0;
    vec_{{funcname}}__append_fmtv0( v, format, ap );
    int const err = errno;
    va_end( ap );
    if ( err ) { errno = err; }
}


void
vec_{{funcname}}__append_fmtv0(
        Vec_{{typename}} * const v,
        char const * const format,
        va_list ap )
{
    ASSERT( v != NULL, vec_{{funcname}}__is_valid( *v ) );

    if ( format == NULL ) { return; }
    char * ext;
    errno = 0;
    // TODO: asprintf is a non-standard GNU/BSD extension to libc; replace
    int const r = vasprintf( &ext, format, ap );
    if ( r < 0 && errno == 0 ) {
        errno = EIO;
    }
    if ( errno ) { return; }
    vec_{{funcname}}__append_str0( v, ext );
    int const append_err = errno;
    free( ext );
    if ( append_err ) { errno = append_err; }
}


{% if 'EQ' in typeclasses %}


bool
vec_{{funcname}}__equal_str(
        Vec_{{typename}} const v,
        char const * const str )
{
    ASSERT( vec_{{funcname}}__is_valid( v ) );

    return arrayc_{{funcname}}__equal_str(
               arrayc_{{funcname}}__view_vec( v ), str );
}


bool
vec_{{funcname}}__equal_str0(
        Vec_{{typename}} const v,
        char const * const str )
{
    ASSERT( vec_{{funcname}}__is_valid( v ) );

    return arrayc_{{funcname}}__equal_str0(
               arrayc_{{funcname}}__view_vec( v ), str );
}


{% endif %} {# EQ #}
{% endif %} {# CHAR #}




{% if 'FROM_STR' in typeclasses %}


void
vec_{{funcname}}__argparse(
        char const * const name,
        char const * const value,
        void * const vec_ptr )
{
    ASSERT( vec_ptr != NULL );

    errno = 0;
    {{type}} const x = {{funcname}}__from_str( value );
    if ( errno ) { return; }
    Vec_{{typename}} * const v = vec_ptr;
    vec_{{funcname}}__append( v, x );
}


{% endif %}

